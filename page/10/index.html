<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Exia.Huang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Exia.Huang">
<meta property="og:url" content="http://www.ibmer.info/page/10/index.html">
<meta property="og:site_name" content="Exia.Huang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Exia.Huang">
  
    <link rel="alternate" href="/atom.xml" title="Exia.Huang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Exia.Huang</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.ibmer.info"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-jvm-heap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/jvm-heap.html" class="article-date">
  <time datetime="2014-10-21T13:03:28.000Z" itemprop="datePublished">2014-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/jvm-heap.html">jvm中堆空间划分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在jvm中堆空间划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和永久代（Permanent Generation）。年轻代和年老代是存储动态产生的对象。永久带主要是存储的是java的类信息，包括解析得到的方法、属性、字段等等。永久带基本 不参与垃圾回收。我们这里讨论的垃圾回收主要是针对年轻代和年老代。具体如下图。</p>
<p><a href="/images/wp-uploads/2014/10/jvm-heap.jpg"><img src="/images/wp-uploads/2014/10/jvm-heap.jpg" alt="jvm-heap"></a></p>
<p>年轻代又分成3个部分，一个eden区和两个相同的survior区。刚开始创建的对象都是放置在eden区的。分成这样3个部分，主要是为了生命 周期短的对象尽量留在年轻带。当eden区申请不到空间的时候，进行minorGC，把存活的对象拷贝到survior。年老代主要存放生命周期比较长的 对象，比如缓存对象。具体jvm内存回收过程描述如下（可以结合上图）：</p>
<p>1、对象在Eden区完成内存分配<br>2、当Eden区满了，再创建对象，会因为申请不到空间，触发minorGC，进行young(eden+1survivor)区的垃圾回收<br>3、minorGC时，Eden不能被回收的对象被放入到空的survivor（Eden肯定会被清空），另一个survivor里不能被GC回收的对象也会被放入这个survivor，始终保证一个survivor是空的<br>4、当做第3步的时候，如果发现survivor满了，则这些对象被copy到old区，或者survivor并没有满，但是有些对象已经足够Old，也被放入Old区 <wbr>XX:MaxTenuringThreshold<br>5、当Old区被放满的之后，进行fullGC</p>
<p>在知道垃圾回收机制以后，大家可以在对jvm中堆的各个参数进行优化设置，来提高性能。</p>
<p>=============</p>
<p><strong>当一个URL被访问时，内存申请过程如下：</strong></p>
<p>A.JVM会试图为相关Java对象在Eden中初始化一块内存区域</p>
<p>B.当Eden空间足够时，内存申请结束。否则到下一步</p>
<p>C.JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的JVM垃圾回收）；释放后若Eden空间仍然不足以放入新对象，则试图将部分</p>
<p>Eden中活跃对象放入Survivor区/OLD区</p>
<p>D.Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区</p>
<p>E.当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）</p>
<p>F.完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”outofmemory错误”。下面看一下JVM垃圾回收机制的Java堆的相关参数。</p>
<p><strong>Java堆相关参数：</strong></p>
<p>ms/mx：定义YOUNG+OLD段的总尺寸，ms为JVM启动时YOUNG+OLD的内存大小；mx为最大可占用的YOUNG+OLD内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。</p>
<p>NewSize/MaxNewSize：定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小；MaxNewSize为最大可占用的YOUNG内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。</p>
<p>PermSize/MaxPermSize：定义Perm段的尺寸，PermSize为JVM启动时Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。</p>
<p>SurvivorRatio：设置Survivor空间和Eden空间的比例</p>
<p>例：</p>
<p>[java]</p>
<p>MEM_ARGS=”-Xms512m-Xmx512m<br>-XX:NewSize=256m-XX:MaxNewSize=256m<br>-XX:PermSize=128m-XX:MaxPermSize=128m<br>-XX:SurvivorRatio=6”</p>
<p>[/java]</p>
<p>在上面的例子中：</p>
<p>[java]</p>
<p>YOUNG+OLD:512M<br>YOUNG:256M<br>Perm:128M<br>Eden:YOUNG*6/(6+1+1)=192M<br>Survivor:YOUNG/(6+1+1)=32M</p>
<p>[/java]</p>
<p>Java堆的总尺寸=YOUNG+OLD+Perm=640M</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/jvm-heap.html" data-id="cji8sg1sk006j40iotgux21ti" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jvm-memory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/jvm-memory.html" class="article-date">
  <time datetime="2014-10-21T12:55:22.000Z" itemprop="datePublished">2014-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/jvm-memory.html">JVM基础：JVM内存组成及分配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>java内存组成介绍：堆(Heap)和非堆(Non-heap)内存</strong></p>
<p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p>
<p><strong>组成图</strong></p>
<p><a href="http://images.51cto.com/files/uploadimg/20120111/1101540.png" target="_blank" rel="external"><img src="http://images.51cto.com/files/uploadimg/20120111/1101540.png" alt=""></a></p>
<p>◆  方法栈&amp;本地方法栈:</p>
<p>线程创建时产生,方法执行时生成栈帧</p>
<p>◆ 方法区</p>
<p>存储类的元数据信息 常量等</p>
<p>◆ 堆</p>
<p>java代码中所有的new操作</p>
<p>◆ native Memory(C heap)</p>
<p>Direct Bytebuffer JNI Compile GC;</p>
<p><strong>堆内存分配</strong></p>
<p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指 定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</p>
<p><a href="http://images.51cto.com/files/uploadimg/20120111/1101541.png" target="_blank" rel="external"><img src="http://images.51cto.com/files/uploadimg/20120111/1101541.png" alt=""></a></p>
<p>&nbsp;</p>
<p><table border="1" width="537" cellspacing="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th valign="top" width="202">组  成</th></p>
<p><th valign="top" width="333">详  解</th><br></p>
<p><tr></tr></p>
<p><td valign="top" width="203">Young Generation</td></p>
<p><td valign="top" width="332">即图中的Eden + From Space + To Space</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="204">Eden</td></p>
<p><td valign="top" width="331">存放新生的对象</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="205">Survivor Space</td></p>
<p><td valign="top" width="331">有两个，存放每次垃圾回收后存活的对象</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="205">Old Generation</td></p>
<p><td valign="top" width="331">Tenured Generation 即图中的Old Space<br>主要存放应用程序中生命周期长的存活对象</td><br><br><br><br>&nbsp;</p>
<p><strong>非堆内存分配</strong></p>
<p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p>
<p>&nbsp;</p>
<p><table border="1" width="540" cellspacing="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th valign="top" width="202">组  成</th></p>
<p><th valign="top" width="600">详  解</th><br></p>
<p><tr></tr></p>
<p><td valign="top" width="203">Permanent Generation</td></p>
<p><td valign="top" width="600">保存虚拟机自己的静态(refective)数据<br>主要存放加载的Class类级别静态对象如class本身，method，field等等<br>permanent generation空间不足会引发full GC(详见<a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037029.html" target="_blank" rel="external">HotSpot VM GC种类</a>)</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="203">Code Cache</td></p>
<p><td valign="top" width="600">用于编译和保存本地代码（native code）的内存<br>JVM内部处理或优化</td><br><br><br><br>&nbsp;</p>
<p><strong>JVM内存限制(最大值)</strong></p>
<p>JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然 可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统 下为2G-3G），而64bit以上的处理器就不会有限制了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/jvm-memory.html" data-id="cji8sg1sn006q40iofksqgsfv" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-constant-pool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java-constant-pool.html" class="article-date">
  <time datetime="2014-10-21T12:31:42.000Z" itemprop="datePublished">2014-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java-constant-pool.html">java内存分配 常量池详解(Constant Pool)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在class文件中，“常量池”是最复杂也最值得关注的内容。</p>
<p>Java是一种动态连接的语言，常量池的作用非常重要，常量池中除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值还，还包含一些以文本形式出现的符号引用，比如：</p>
<p>类和接口的全限定名；</p>
<p>字段的名称和描述符；</p>
<p>方法和名称和描述符。</p>
<p>在C语言中，如果一个程序要调用其它库中的函数，在连接时，该函数在库中的位置（即相对于库文件开头的偏移量）会被写在程序中，在运行时，直接去这个地址调用函数；</p>
<p>而在Java语言中不是这样，一切都是动态的。编译时，如果发现对其它类方法的调用或者对其它类字段的引用的话，记录进class文件中的，只能是一个文本形式的符号引用，在连接过程中，虚拟机根据这个文本信息去查找对应的方法或字段。</p>
<p>所以，与Java语言中的所谓“常量”不同，class文件中的“常量”内容很非富，这些常量集中在class中的一个区域存放，一个紧接着一个，这里就称为“常量池”。</p>
<p>转: <a href="http://hi.baidu.com/rickmeteor/blog/item/f0be11dff578ba1662279848.html" target="_blank" rel="external">http://hi.baidu.com/rickmeteor/blog/item/f0be11dff578ba1662279848.html</a></p>
<p>java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复重复创建相等变量时节省了很多时间。常量池其实也就是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。本文只从java使用者的角度来探讨java常量池技术，并不涉及常量池的原理及实现方法。个人认为，如果是真的专注java,就必须对这些细节方面有一定的了解。但知道它的原理和具体的实现方法则不是必须的。</p>
<p>1,常量池中对象和堆中的对象</p>
<p>[java]</p>
<p>public class Test{</p>
<p>Integer i1=new Integer(1);<br>Integer i2=new Integer(1);<br>//i1,i2分别位于堆中不同的内存空间</p>
<p>System.out.println(i1==i2);//输出false<br>Integer i3=1;<br>Integer i4=1;<br>//i3,i4指向常量池中同一个内存空间</p>
<p>System.out.println(i3==i4);//输出true</p>
<p>//很显然，i1,i3位于不同的内存空间</p>
<p>System.out.println(i1==i3);//输出false</p>
<p>}</p>
<p>[/java]</p>
<p>2，8种基本类型的包装类和对象池</p>
<p>java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,<span style="color: #ff0000;"><strong>另外两种浮点数类型的包装类则没有实现。</strong></span>另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在<span style="color: #ff0000;"><strong>对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象</strong></span>。以下是一些对应的测试代码：</p>
<p>[java]</p>
<p>public class Test{</p>
<p>public static void main(String[] args){</p>
<p>//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</p>
<p>//在值小于127时可以使用常量池</p>
<p>Integer i1=127;</p>
<p>Integer i2=127;</p>
<p>System.out.println(i1==i2)//输出true</p>
<p>//值大于127时，不会从常量池中取对象</p>
<p>Integer i3=128;</p>
<p>Integer i4=128;</p>
<p>System.out.println(i3==i4)//输出false</p>
<p>//Boolean类也实现了常量池技术</p>
<p>Boolean bool1=true;</p>
<p>Boolean bool2=true;</p>
<p>System.out.println(bool1==bool2);//输出true</p>
<p>//浮点类型的包装类没有实现常量池技术</p>
<p>Double d1=1.0;</p>
<p>Double d2=1.0;</p>
<p>System.out.println(d1==d2)//输出false</p>
<p>&nbsp;</p>
<p>}</p>
<p>}</p>
<p>[/java]</p>
<p>3,String也实现了常量池技术</p>
<p>String类也是java中用得多的类，同样为了创建String对象的方便，也实现了常量池的技术,测试代码如下:</p>
<p>[java]</p>
<p>public class Test{</p>
<p>public static void main(String[] args){</p>
<p>//s1,s2分别位于堆中不同空间</p>
<p>String s1=new String(“hello”);</p>
<p>String s2=new String(“hello”);</p>
<p>System.out.println(s1==s2)//输出false</p>
<p>//s3,s4位于池中同一空间</p>
<p>String s3=”hello”;</p>
<p>String s4=”hello”;</p>
<p>System.out.println(s3==s4);//输出true</p>
<p>}</p>
<p>}</p>
<p>[/java]</p>
<p>最后:</p>
<p>细节决定成败，写代码更是如此。</p>
<p>对Integer对象的补充:<a href="http://hi.baidu.com/fandywang_jlu/blog/item/c5590b4eae053cc3d1c86a13.html" target="_blank" rel="external">http://hi.baidu.com/fandywang_jlu/blog/item/c5590b4eae053cc3d1c86a13.html</a></p>
<p>Integer的封装吧：</p>
<p>[java]</p>
<p>public static Integer valueOf(int i) {</p>
<p>final int offset = 128;</p>
<p>if (i &gt;= -128 &amp;&amp; i &lt;= 127) { // must cache</p>
<p>return IntegerCache.cache[i + offset];</p>
<p>}</p>
<p>return new Integer(i);<br>}</p>
<p>[/java]<br>当你直接给一个Integer对象一个int值的时候，其实它调用了valueOf方法，然后你赋的这个值很特别，是128，那么没有进行cache方法，相当于new了两个新对象。所以问题中定义a、b的两句代码就类似于：</p>
<pre><code>Integer a = new Integer(128);

Integer b = new Integer(128);
</code></pre><p>这个时候再问你，输出结果是什么？你就知道是false了。如果把这个数换成127，再执行：</p>
<pre><code>Integer a = 127;

Integer b = 127;

System.out.println(a == b);
</code></pre><p>结果就是：true</p>
<p>由上可知，我们进行对象比较时最好还是使用equals，便于按照自己的目的进行控制。</p>
<p>————————————————–补充———————————————————————–</p>
<p>   我们看一下IntegerCache这个类里面的内容：</p>
<p>[java]</p>
<p>private static class IntegerCache {</p>
<p>private IntegerCache() {</p>
<p>}</p>
<p>static final Integer cache[] = new Integer[-(-128) + 127 + 1];</p>
<p>static {</p>
<p>for (int i = 0; i &lt; cache.length; i++)</p>
<p>cache[i] = new Integer(i - 128);</p>
<p>}</p>
<p>}</p>
<p>[java]</p>
<p>由于cache[]在IntegerCache类中是静态数组，也就是只需要初始化一次，即static｛……｝部分，所以，如果Integer对象初始化时是-128~127的范围，就不需要再重新定义申请空间，都是同一个对象—在IntegerCache.cache中，这样可以在一定程度上提高效率。</p>
<p>//////////////////////////////////////////////////////////对String方面的补充///////////////////////////////////////////////////////////</p>
<p>来自SUN官方文档:</p>
<p>3.10.5 String Literals</p>
<p>A string literal consists of zero or more characters enclosed in double quotes. Each character may be represented by an escape sequence.</p>
<p>A string literal is always of type String (<a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#26992" target="_blank" rel="external">§4.3.3</a>. A string literal always refers to the same instance <a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#12028" target="_blank" rel="external">(§4.3.1)</a> of class String.</p>
<p>StringLiteral:</p>
<p> “ StringCharacters<sub>opt</sub> “</p>
<p>StringCharacters:</p>
<p> StringCharacter</p>
<p> StringCharacters StringCharacter</p>
<p>StringCharacter:</p>
<p> InputCharacter but not “ or \</p>
<p> EscapeSequence</p>
<p>The escape sequences are described in <a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#101089" target="_blank" rel="external">§3.10.6</a>.</p>
<p>As specified in <a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#231571" target="_blank" rel="external">§3.4</a>, neither of the characters CR and LF is ever considered to be an InputCharacter; each is recognized as constituting a LineTerminator.</p>
<p>It is a compile-time error for a line terminator to appear after the opening “ and before the closing matching “. A long string literal can always be broken up into shorter pieces and written as a (possibly parenthesized) expression using the string concatenation operator + <a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#39990" target="_blank" rel="external">(§15.18.1)</a>.</p>
<p>The following are examples of string literals:</p>
<p>“”    // the empty string</p>
<p>“\””    // a string containing “ alone</p>
<p>“This is a string”  // a string containing 16 characters</p>
<p>“This is a “ +   // actually a string-valued constant expression,</p>
<p> “two-line string” //  formed from two string literals</p>
<p>Because Unicode escapes are processed very early, it is not correct to write “\u000a” for a string literal containing a single linefeed (LF); the Unicode escape \u000a is transformed into an actual linefeed in translation step 1 <a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#100850" target="_blank" rel="external">(§3.3)</a> and the linefeed becomes a LineTerminator in step 2 <a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#231571" target="_blank" rel="external">(§3.4)</a>, and so the string literal is not valid in step 3. Instead, one should write “\n” <a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#101089" target="_blank" rel="external">(§3.10.6)</a>. Similarly, it is not correct to write “\u000d” for a string literal containing a single carriage return (CR). Instead use “\r”.</p>
<p>Each string literal is a reference <a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#9317" target="_blank" rel="external">(§4.3)</a> to an instance (<a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#12028" target="_blank" rel="external">§4.3.1</a>, <a href="http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html#44670" target="_blank" rel="external">§12.5</a>) of class String (<a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#26992" target="_blank" rel="external">§4.3.3</a>). String objects have a constant value. String literals-or, more generally, strings that are the values of constant expressions <a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5313" target="_blank" rel="external">(§15.28)</a>-are “interned” so as to share unique instances, using the method String.intern.</p>
<p>Thus, the test program consisting of the compilation unit <a href="http://java.sun.com/docs/books/jls/second_edition/html/packages.doc.html#40031" target="_blank" rel="external">(§7.3)</a>:</p>
<p>package testPackage;</p>
<p>class Test {</p>
<p> public static void main(String[] args) {</p>
<p>  String hello = “Hello”, lo = “lo”;</p>
<p>  System.out.print((hello == “Hello”) + “ “);</p>
<p>  System.out.print((Other.hello == hello) + “ “);</p>
<p>  System.out.print((other.Other.hello == hello) + “ “);</p>
<p>  System.out.print((hello == (“Hel”+”lo”)) + “ “);</p>
<p>  System.out.print((hello == (“Hel”+lo)) + “ “);</p>
<p>  System.out.println(hello == (“Hel”+lo).intern());</p>
<p> }</p>
<p>}</p>
<p>class Other { static String hello = “Hello”; }</p>
<p>and the compilation unit:</p>
<p>package other;</p>
<p>public class Other { static String hello = “Hello”; }</p>
<p>produces the output:</p>
<p>true true true true false true</p>
<p>This example illustrates six points:</p>
<ul>
<li>Literal strings within the same class <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#3857" target="_blank" rel="external">(§8)</a> in the same package <a href="http://java.sun.com/docs/books/jls/second_edition/html/packages.doc.html#34412" target="_blank" rel="external">(§7)</a> represent references to the same String object <a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#12028" target="_blank" rel="external">(§4.3.1)</a>.</li>
</ul>
<p><span style="text-decoration: underline;">在同包同类下,引用自同一String对象.</span></p>
<ul>
<li>Literal strings within different classes in the same package represent references to the same String object.</li>
</ul>
<p><span style="text-decoration: underline;">在同包不同类下,引用自同一String对象.</span></p>
<ul>
<li>Literal strings within different classes in different packages likewise represent references to the same String object.</li>
</ul>
<p><span style="text-decoration: underline;">在不同包不同类下,依然引用自同一String对象.</span></p>
<ul>
<li>Strings computed by constant expressions <a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5313" target="_blank" rel="external">(§15.28)</a> are computed at compile time and then treated as if they were literals.</li>
</ul>
<p><span style="text-decoration: underline;">在编译成.class时能够识别为同一字符串的,自动优化成常量,所以也引用自同一String对象.</span></p>
<ul>
<li>Strings computed at run time are newly created and therefore distinct.</li>
</ul>
<p><span style="text-decoration: underline;">在运行时创建的字符串具有独立的内存地址,所以不引用自同一String对象.</span></p>
<ul>
<li>The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.</li>
</ul>
<p><span style="text-decoration: underline;">String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,</span></p>
<p><span style="text-decoration: underline;">如果有则返回一个引用,没有则添加自己的字符串进进入常量池,</span></p>
<p><span style="text-decoration: underline;">注意,只是字符串部分,</span></p>
<p><span style="text-decoration: underline;">所以这时会存在2份拷贝,常量池的部分被String类私有持有并管理,自己的那份按对象生命周期继续使用.</span></p>
<p>API解释:</p>
<p>返回字符串对象的规范化表示形式。</p>
<p>一个初始时为空的字符串池，它由类 String 私有地维护。</p>
<p>当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 <a href="mk:@MSITStore:F:%20API%20jdk150.ZH_cn.chm::/jdk150/api/java/lang/String.html#equals(java.lang.Object" target="_blank" rel="external">equals(Object)</a>) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。</p>
<p>它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。</p>
<p>所有字面值字符串和字符串赋值常量表达式都是内部的。字符串字面值在《<a href="http://java.sun.com/docs/books/jls/html/" target="_blank" rel="external">Java Language Specification</a>》的 §3.10.5 中已定义。</p>
<p>————————————代码演示补充————————————-</p>
<p>   String s0= “java”;</p>
<p>   String s1=new String(“java”);</p>
<p>   String s2=new String(“java”);</p>
<p>   s1.intern();</p>
<p>   s2=s2.intern(); //把常量池中“kvill”的引用赋给s2</p>
<p>   System.out.println( s0==s1);//false intern返回的引用没有引用变量接收~    s1.intern();等于废代码.</p>
<p>   System.out.println( s0==s1.intern() );//true</p>
<p>   System.out.println( s0==s2 );//true</p>
<p>————————————代码演示补充————————————-</p>
<p>   String s1=new String(“java”);<br>String s2=s1.intern();//s1 检查常量池 发现没有 就拷贝自己的字符串进去</p>
<p>//s2 引用该字符串常量池的地址</p>
<p>   System.out.println(s2 == s1);//false<br>System.out.println( s2==s1.intern());//true<br>System.out.println( s1==s1.intern());// false</p>
<p>最后引出equals()和==的故事</p>
<p>对于字符串比较,一定要切记使用equals,勿用==</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/java-constant-pool.html" data-id="cji8sg1sd006540iow41hnthb" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-was-mq-2009error" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/was-mq-2009error.html" class="article-date">
  <time datetime="2014-10-21T08:41:42.000Z" itemprop="datePublished">2014-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiddleWare/">MiddleWare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/was-mq-2009error.html">WAS连接MQ错误</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>WAS连接MQ，出现了下面的错误</p>
<p>【A connection could not be made to WebSphere MQ for the following reason: CC=2;RC=2009】</p>
<p><a href="/images/wp-uploads/2014/10/WAS-MQ-2009err.jpg"><img src="/images/wp-uploads/2014/10/WAS-MQ-2009err.jpg" alt="WAS-MQ-2009err"></a></p>
<p>问题解决：1）查看OSGi，2）MQ Lib配置</p>
<p>&nbsp;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/was-mq-2009error.html" data-id="cji8sg1wg00dv40io57lhqo8b" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/was/">was</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-was-resource" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/was-resource.html" class="article-date">
  <time datetime="2014-10-16T08:43:49.000Z" itemprop="datePublished">2014-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiddleWare/">MiddleWare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/was-resource.html">WAS相关资源信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>===================WAS=================================</p>
<p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg27038624" target="_blank" rel="external">download WebSphere Application Server Network Deployment V8.5.5</a></p>
<p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg27024154" target="_blank" rel="external">How to download WebSphere Application Server Network Deployment V8.5</a></p>
<p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg27013045" target="_blank" rel="external">Download WebSphere Application Server Network Deployment Version 7.0</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1012_dingsj_wascluster/1012_dingsj_wascluster.html" target="_blank" rel="external">在 WebSphere Application Server V7 集群环境中管理 HTTP session</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/websphere/tutorials/1107_chenzx_httpsession/" target="_blank" rel="external">HTTP Session 内存到内存复制的拓扑结构</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1308_wangh_wasport/1308_wangh_wasport.html" target="_blank" rel="external">如何利用 Profile Port Checker 来解决 WebSphere Application Server 端口冲突问题</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/webservices/ws-soapojms/" target="_blank" rel="external">在 SOAP over JMS Web 服务中使用 WebSphere MQ，第 1 部分: 部署和配置 Web 服务</a></p>
<p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg21231315&amp;acss=dakc" target="_blank" rel="external">WAS中配置MQ变量：<strong>MQ_INSTALL_ROOT</strong> and <strong>MQJMS_LIB_ROOT</strong>变量</a></p>
<p><a href="http://www-01.ibm.com/support/docview.wss?rs=171&amp;uid=swg27016505" target="_blank" rel="external">Using WebSphere MQ V7 as JMS Provider for WebSphere Application Server V7, V8.0 and V8.5</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/0912_wangzq_wasosgi/" target="_blank" rel="external">实现 WebSphere Application Server 上应用程序对 OSGi 的支持</a></p>
<p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg21514310" target="_blank" rel="external">Fixes by version for IBM Security Access Manager for Web/Mobile</a></p>
<p>===================AIX=================================</p>
<p><a href="http://www.ibm.com/developerworks/cn/aix/library/au-powerhaintro/" target="_blank" rel="external">PowerHA 简介</a></p>
<p>===================DB2=================================</p>
<p><a href="http://my.oschina.net/chen106106/blog/45185" target="_blank" rel="external">Redhat Linux 5.3环境实施DB2 V9.7 HADR</a></p>
<p>===================MQ==================================</p>
<p><a href="http://www-01.ibm.com/software/integration/wmq/explorer/downloads/" target="_blank" rel="external">IBM WebSphere MQ Explorer</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/0907_yangj_mq-oam/" target="_blank" rel="external">基于 OAM 实现 WebSphere MQ 对象访问控制</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/websphere/techjournal/0909_mismes/0909_mismes.html" target="_blank" rel="external">任务：消息: 不可或缺的十种 WebSphere MQ SupportPac</a></p>
<p><a href="http://www-01.ibm.com/support/docview.wss?rs=171&amp;uid=swg27007197#1" target="_blank" rel="external">WebSphere MQ - SupportPacs by Product</a></p>
<p><a href="http://wenku.baidu.com/link?url=68DaMTK17Mw3WGgv-kFvrl2Aplz1p05B8BLHXvrMYQftmVC4EIpLtmdCfLrlI2Ics2HjbUXqdnpigUs6j9UPGwX0kGSiuFL5lka1AJ7RYZe" target="_blank" rel="external">IBM MQ入门</a></p>
<p>===================JAVA等其他===============================</p>
<p><a href="http://developer.51cto.com/art/200909/152190.htm" target="_blank" rel="external">OSGi是什么：Java语言的动态模块系统</a></p>
<p>&nbsp;</p>
<p>=======================================================</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/was-resource.html" data-id="cji8sg1wh00dy40ionr1s6c94" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/was/">was</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-websphere7-multi-port" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/websphere7-multi-port.html" class="article-date">
  <time datetime="2014-10-16T08:27:57.000Z" itemprop="datePublished">2014-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiddleWare/">MiddleWare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/websphere7-multi-port.html">WebSphere7: 修改端口，建立多端口应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在websphere7上发布了一个简单的应用，模式使用的是概要建立时的端口号9080（每建立一个新的概要，次端口号会自动加1），希望能够改变这个端口号，于是开始试验。</p>
<p>1. 应用程序服务器 &gt; server1 &gt; Web 容器设置 &gt; Web 容器传输链可以查看到server1目前可以使用的端口。</p>
<p>WCInboundAdminSecure 为控制台访问端口；WCInboundDefault为应用访问端口；此时我们可以使用两个方法：</p>
<p>1）、修改WCInboundDefault的端口，点击此链接，进入后选择TCP 入站通道（TCP_2），发现端口处是选择项，于是可以使用右边的相关项-&gt;端口，查看并建立新的端口20099，端口建立后回到之前的TCP 入站通道（TCP_2），选择建立的端口即可。</p>
<p>2）、新建web容器传输链，在Web 容器传输链页面点击新建，录入传输链名称，并选择相应的模版，点击下一步；此时需要设置端口，可以选择已经存在的端口，或者直接在此处新建端口，主机可以使用*，端口录入20099，点击完成。建立多个传输链意味着可以通过多个端口访问web应用，例如<a href="http://localhost:9080/helloworld/，http://localhost:20099/helloworld/访问的是同一个应用。" target="_blank" rel="external">http://localhost:9080/helloworld/，http://localhost:20099/helloworld/访问的是同一个应用。</a></p>
<p>2. 修改此配置后需要重启服务器。重启后在浏览器中录入<a href="http://localhost:20099/helloworld/结果报错，显示如下：" target="_blank" rel="external">http://localhost:20099/helloworld/结果报错，显示如下：</a></p>
<p>SRVE0255E: 尚未定义要处理 /helloworld/ 的 Web 组/虚拟主机。</p>
<p>SRVE0255E: 尚未定义要处理 localhost:20099 的 Web 组/虚拟主机。</p>
<p>IBM WebSphere Application Server</p>
<p>经多方查证，最后得知：在was中建立的第一个服务，was会自动把该服务与系统端口及机器名关联，但是从第二个后就需要DNS别名手动绑定一下，需要将端口与虚拟主机进行绑定。</p>
<p>3. 绑定端口到虚拟主机，选择环境 &gt; 虚拟主机 &gt; default_host，并点击主机别名，可以看到已经设置的主机别名和端口号（例如：<a href="http://www.jack.com:9080，主机别名为www.jack.com，端口为9080，当然设置时可以使用&quot;*&quot;进行匹配）。" target="_blank" rel="external">http://www.jack.com:9080，主机别名为www.jack.com，端口为9080，当然设置时可以使用&quot;*&quot;进行匹配）。</a></p>
<p>点击新建，加入20099端口，主机别名设置为*，重新启动服务器。</p>
<p>4. 服务器启动后，在浏览器中输入<a href="http://localhost:20099/helloworld/发现可以正常显示了，当然如果是通过新建传输链方式添加的端口，则http://localhost:9080/helloworld/仍然能正确访问。" target="_blank" rel="external">http://localhost:20099/helloworld/发现可以正常显示了，当然如果是通过新建传输链方式添加的端口，则http://localhost:9080/helloworld/仍然能正确访问。</a></p>
<p>感言：websphere很强大，但也很简单，只是需要我们发现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/websphere7-multi-port.html" data-id="cji8sg1wt00en40iof2j7fx2v" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/was/">was</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cluster-tech2-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/cluster-tech2-2.html" class="article-date">
  <time datetime="2014-10-16T03:02:56.000Z" itemprop="datePublished">2014-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiddleWare/">MiddleWare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/cluster-tech2-2.html">集群的可扩展性及其分布式体系结构（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="可扩展的并行计算体系结构"><a href="#可扩展的并行计算体系结构" class="headerlink" title="可扩展的并行计算体系结构"></a>可扩展的并行计算体系结构</h2><p>首先，我们先来看一下计算机系统体系结构发展的几个主要类型。每种体系结构的差别并不大，关键在于互联技术、结点的复杂度和耦合程度的不同。在集群计算和分布式系统中，以下这三种体系结构是比较具有代表性的。</p>
<ul>
<li><strong>无共享体系结构</strong><br><img src="http://www.ibm.com/developerworks/cn/linux/cluster/cluster_system/base/part2/fig2.gif" alt="无共享体系结构"><br>无共享体系结构<br>（目前大多数集群采用的方式。每个节点都是独立的PC或者工作站）我们研究的集群系统大多数属于这一类的体系结构。集群的每一个结点都是完整独立的操作系统和硬件设备集合。结点之间通过局域网或者开关阵列以松耦合的方式 连接起来，彼此分享结点的部分甚至全部可用资源：CPU、内存、磁盘、IO设备等等，以形成一个对外单一、强大的计算机系统。这类系统对SSI的能力较 弱，需要特殊的中间件或者OS扩展加以支持。</li>
<li><strong>共享磁盘体系结构</strong><img src="http://www.ibm.com/developerworks/cn/linux/cluster/cluster_system/base/part2/fig3.gif" alt="共享磁盘体系结构"><br><strong>共享磁盘体系结构<br>（结点基本上仍是独立的计算机，没有或者不使用本地的磁盘文件系统） </strong>分布式文件系统正是这类体系结构的应用体现。常见的NFS、AFS或者GFS都属于这个范畴。而硬件上的解决常常通过共享磁盘阵列或者SAN来实现。该体 系结构主要能够解决区域存储空间的容量问题，通过构造单一的虚拟的文件系统，提供给整个集群一个巨大的存储设备。尤其在一些高可用的场合，共享磁盘阵列常 常能够解决文件系统容错和数据一致等可靠性问题。</li>
<li><strong>共享存储器体系结构</strong><img src="http://www.ibm.com/developerworks/cn/linux/cluster/cluster_system/base/part2/fig4.gif" alt="共享存储器体系结构（最不易实现，具有较强的SSI能力）"><br><strong>共享存储器体系结构（最不易实现，具有较强的SSI能力）</strong>从实现的难度上讲，不论是硬件制造的复杂性还是软件的实现难度，这种体系结构都大大超过其他几类体系结构的实现。实现这类体系结构的集群系统有DSM（分 布式共享存储集群）、NUMA、ccNUMA等技术。在这类体系结构中，可以将多个节点的计算资源集合在一起，形成一个内存空间一致的单一系统。在随后的 学习中我们知道，这样的系统具有最好的SSI（单一系统映像）能力。</li>
</ul>
<h2 id="可扩展与单一系统映象"><a href="#可扩展与单一系统映象" class="headerlink" title="可扩展与单一系统映象"></a>可扩展与单一系统映象</h2><p>我们最终希望，我们所面对的并行集群，不管适用于密集计算还是高可靠商用环境，都要有良好的可扩展性，可接受的单位计算成本，可预期的技术前景。因此，设计一个计算系统特别是并行环境下的集群系统，时时刻刻别忘了可扩展性这一核心的要求。</p>
<p>但我们从另外一个角度来看待并行计算集群的时候，就会有不同的结论了。其实，对于最终用户和编程人员来说，并行计算机模型的重点在于他们所看到的计算机是什么样的，也就是我们通常所称的SSI（单一系统映像）。</p>
<p>如果作为编程者，当然希望自己所面对的是一台机器而不是一堆机器，一台机器意味着单一的寻址空间，无须处理消息传递或者远程调用这样复杂的编程技术。那 么，在这样的观点下，具有单一地址空间的集群系统就具备了这个能力；或者使用者希望拥有一个巨大的一致的（只有一个根目录）的文件系统，那就需要在文件系 统层次上进行SSI的工作。</p>
<p>但从用户的角度来看，他并不关心你是如何处理诸如地址空间、消息传递这些看起来和他毫无关系的东西，用户只关心他用的是一台独立的计算机系统，这样可以减 少他使用的复杂度，不需要在多个系统之间来回切换，可以方便的管理他所面对的”一台机器”。那么，提供管理层次和使用层次的SSI就是必要的了。</p>
<p>所以，并行计算模型就是由使用者（包括程序员、用户）看到的一个抽象并行计算机，和冯氏结构计算机相似，能够进行顺序计算（其背后可能是并行的运算程序）和并行计算任务的计算机系统。</p>
<p>按照处理器、内存、OS以及互联方法来进行并行系统的分类，在参考彼此可扩展性和单一系统映像的这两个方面，我们能够得到下面的图形：</p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/cluster/cluster_system/base/part2/fig5.gif" alt="集群、分布式系统、MPP、SMP的体系结构比较"></p>
<p>集群、分布式系统、MPP、SMP的体系结构比较</p>
<p>上图中，节点可以是一台PC、一台工作站或者SMP服务器。节点的复杂性指的是软件和硬件的能力。一般来说，集群节点要比MPP复杂一些，因为每个集群结点都有独立的操作系统和外围设备，而MPP中的结点可能仅仅是操作系统的一个微内核。</p>
<p>SMP服务器的节点复杂性和PC以及商用集群相比，相对高一些。拿最常见的x86构架SMP服务器来说吧，不但主板、总线技术都远远比PC复杂。而且为了 支持企业级应用环境，SMP还需要支持更多的高端外设，提供存储设备的热拔插能力，内存数据纠错等等高端技术，这些技术的应用势必增加SMP的复杂程度。</p>
<p>MPP通常是指采用无共享资源结构的大型并行处理系统，一般包括几百个处理器节点，节点一般运行一个不完整的OS（也叫微内核），结点之间通过高速开关互联。这样的专有系统往往具有比较好的可扩展能力，但是在技术换代上受限于专有系统本身。</p>
<p>SSI作为集群实现的一大要素，其范围包括了单一的应用层次、子系统，运行时系统、操作系统内核以及硬件层次。或者说，SSI不是绝对的，是一个相对的概 念，取决于用户从什么样的角度看待系统，是IP层面上还是内存空间上或者是文件系统的SSI，这都由最终的应用环境决定。</p>
<p>到了分布式系统的这个范畴，系统往往提供多个系统映象，呈现出一个多入口、多映象的系统集合，每个节点具有很高的自治能力。而MPP、SMP则以紧凑的方 式提供相对单一的计算资源，如同一个巨大的工作站。在分布式系统中，除了使用同构结点外，还根据需要常常使用异构的平台，这势必增加分布式系统的设计难度 和管理复杂性。其他特性见下表：</p>
<p><table class="ibm-data-table" border="1" width="100%" cellspacing="0" cellpadding="5"></table></p>
<p><thead></thead></p>
<p><tr></tr></p>
<p><th>特征</th></p>
<p><th>MPP</th></p>
<p><th>SMP</th></p>
<p><th>集群</th></p>
<p><th>分布式系统</th><br><br></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td><strong>结点个数</strong></td></p>
<p><td>100~1000数量级</td></p>
<p><td>10～100数量级</td></p>
<p><td>100左右的数量级</td></p>
<p><td>10～1000以上数量级</td><br></p>
<p><tr></tr></p>
<p><td><strong>结点复杂性</strong></td></p>
<p><td>细粒度到中粒度</td></p>
<p><td>中或粗粒度</td></p>
<p><td>中粒度</td></p>
<p><td>大范围</td><br></p>
<p><tr></tr></p>
<p><td><strong>结点间通信</strong></td></p>
<p><td>消息传递或者共享变量</td></p>
<p><td>共享存储器</td></p>
<p><td>消息传递</td></p>
<p><td>共享文件、RPC、消息传递</td><br></p>
<p><tr></tr></p>
<p><td><strong>任务调度</strong></td></p>
<p><td>主机单一队列</td></p>
<p><td>单一运行队列</td></p>
<p><td>多队列协同运行</td></p>
<p><td>独立的运行队列</td><br></p>
<p><tr></tr></p>
<p><td><strong>单一系统映像</strong></td></p>
<p><td>部分支持</td></p>
<p><td>支持完全的SSI</td></p>
<p><td>某一层次支持</td></p>
<p><td>目前不支持</td><br></p>
<p><tr></tr></p>
<p><td><strong>结点操作系统</strong></td></p>
<p><td>一个主要的内核和多个微内核</td></p>
<p><td>独立的完整的OS</td></p>
<p><td>N个同类OS</td></p>
<p><td>同类OS或异构OS</td><br></p>
<p><tr></tr></p>
<p><td><strong>地址空间</strong></td></p>
<p><td>多/单地址空间（分布式共享内存）</td></p>
<p><td>单一</td></p>
<p><td>多</td></p>
<p><td>多</td><br></p>
<p><tr></tr></p>
<p><td><strong>系统可用性</strong></td></p>
<p><td>低或中</td></p>
<p><td>低</td></p>
<p><td>高或者容错</td></p>
<p><td>中等</td><br></p>
<p><tr></tr></p>
<p><td><strong>归属单位</strong></td></p>
<p><td>一个组织</td></p>
<p><td>一个组织</td></p>
<p><td>可以多个组织（复用）</td></p>
<p><td>多组织</td><br></p>
<p><tr></tr></p>
<p><td><strong>连接距离</strong></td></p>
<p><td>紧耦合，在一个物理空间内</td></p>
<p><td>紧耦合，在一个机箱内</td></p>
<p><td>松耦合，楼区范围（依赖于连接介质）</td></p>
<p><td>松耦合，跨地域（地区或国家）</td><br><br><br><br><strong>各类并行系统的比较</strong></p>
<p>对于这四类系统来说，SMP的SSI程度最高，它是在所有的层次上提供SSI，即共享一切系统资源：单一地址空间、单一的文件系统、单一的操作系统内核等 等，看起来和一台单独的单CPU没什么两样。MPP仅仅在某些应用层和系统层支持SSI。集群提供的SSI程度更低，一般只能满足某一两个方面的SSI要 求。而对于分布式系统，比如网格，其SSI的实现程度就低的多了。通过类似JAVA这样的跨平台工具，分布式系统或许可以提供某一定义下的SSI能力，比 如单一的JAVA运行空间。</p>
<h2 id="集群的重要指标"><a href="#集群的重要指标" class="headerlink" title="集群的重要指标"></a>集群的重要指标</h2><p>对 于集群，我们可以得到这样的一个简单的概念：集群是全体计算机（也叫节点）的集合，这些计算机由高性能网络或者LAN物理的相连。典型的情况下，每个计算 机结点可以是一台SMP一台工作站或者是最普通不过的PC。最重要的是，这些各自独立的计算机要能够同心协力一起工作，而且在”外”看上去是单一的集成的 计算机资源。</p>
<p>如果只是简单的用LAN把集群连接起来，就称之为集群，是不可能具备实用价值的。考察集群很重要的是看待集群的几个性能、功能指标。</p>
<p><strong>能用性：</strong>由于集群中的每个节点都是运行传统平台，故用户能在熟悉和成熟的环境中开发 和运行他们的程序。通用平台提供编程环境、操作界面、控制监控系统的工具甚至是GUI，允许用户们运行他们原来在工作站上的大量程序而无需修改。所以，我们可以把集群系统看作一个大型的工作站，作为使用者，和平时操作没什么两样，只是性能提高了许多。</p>
<p><strong>可用性：</strong>可用性是指一个系统从事生产性使用的时间百分比（MTBF平均无故障时间）。传统的整体系统，比如主机系统和容错系统依靠昂贵的定制设计来实现高可用性。集群不使用定制组件，而使用廉价的商品化组件以提供高可用性，而高度的设备冗余则是集群最常使用的方式：</p>
<ul>
<li>处理器和存储器：集群有多个处理器和存储器部件，当某个部件失效时，其他的仍然可以使用，不影响集群整体的运行。与此相反，在SMP中，由于处理器通过共享存储器和总线通信，所以存储器一旦失效将会导致系统崩溃。存储器就成了SMP的”单点失效”。</li>
<li>磁 盘阵列：我们常见的RAID 0或者5，都能够满足计算机的磁盘冗余容错需求。在集群中，往往使用多个局部磁盘，通过标准的共享协议（NFS，IFS等）以支持容错需求。当某个节点的 本地磁盘失效时，可以通过远程磁盘继续运行。常见的有NAS设备，一种专用于集群网络存储的磁盘设备。或者借助分布式文件系统软件，实现多个集群节点之间 的磁盘容错。</li>
<li>操作系统：一般的说，集群在某一层次上体能够实现单一系统映像。但是多个操作系统映像还是存在的，每个节点都有一个独立的操作系统。当某个节点因为软件或 硬件故障而崩溃，其他的节点仍然不受影响继续工作，而整个集群也和原先没有什么两样。我们有时也把这一特性叫做”节点容错能力”。</li>
<li>通信网络：好的集群设计充分考虑了各种可能出现的故障情况，并采取一切可行的措施加以避免。集群结点的通信故障也是必须考虑的。在一个大型的复杂的集群 中，一段通信链路的故障可能导致不止一个的节点失效，甚至会使得整个集群变得不可用。因此，在集群的关键点之间采取合适的冗余链路就非常必要了。一般考虑 到集群的入口节点、主控结点、或者监视节点比较容易成为单点失效，那么在这些节点的接入策略中，使用备份链路可以达到比较好的效果。<br><strong>可扩展性：</strong>一个集群的计算能力随结点增多而增加。其次，集群的可扩展性是群体可扩展性。因为是松耦合的结构，集群能扩展至几百个结点，而对于SMP来讲，要超过几十个结点就非常困难。</li>
</ul>
<p>在SMP中，共享存储器以及存储器总线是系统性能的瓶颈。相同的程序集运行于集群时，不存在存储器瓶颈。每个结点可在一个结点上执行，充分使用局部存储 器。对于这类应用，集群可提供更高的总体存储器带宽和减少存储器时延。集群的局部磁盘也聚集为大磁盘空间，可容易地超过集中式RAID磁盘空间。增强的处 理、存储和I/O能力使得集群只要使用经良好开发的、如PVM或MPI那样的并行软件包，就可求解大型应用问题。</p>
<p>SMP不具有高可扩展能力，因为它使用竞争总线和集中式共享存储器。单操作系统映像及共享存储器是两个潜在的单失效点，会降低SMP的可用性。</p>
<p>容错系统有极高的可用性，但扩展的代价昂贵。而MPP的扩展能力要更强一些，而且可以保持比较好的SSI能力。目前，集群处于相对折衷的位置，将向着更高性能更高可用性的方向扩展。</p>
<p><strong>性能价格比：</strong>集群能成本有效的获取上述优点。传统的超级计算机以及MPP的成本很易达到几千万美元。与此相比，具有相同峰值性能的集群价格则要低1到2个数量级。集群大量的采用商品化部件，他们的性能和价格遵循摩尔定律，从而使集群的性能/成本比的增长速率远快于MPP。</p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/cluster/cluster_system/base/part2/fig6.gif" alt="可用性与可伸缩性的综合比较"></p>
<p>可用性与可伸缩性的综合比较</p>
<p>设计一个具有良好的扩展集群系统，就要兼顾上述的方方面面。</p>
<p>首先尽量使集群的各个组成部件相互独立，以使独立的局部扩展成为可能，并且保证向后兼容的特性。还要尽可能采用商品化的组件，包括OS、互联网络、主机系统甚至是应用编程环境。最终实现：算法独立于体系结构、应用独立于平台、语言独立于机器、结点独立于网络。</p>
<p>其次就是选择合适的实现模型来进行集群系统的设计任务，尽量使用流行的开放的标准件，以降低单位成本。</p>
<p>最后，在设计的时候还要尽量平衡性能，避免系统里出现的”木桶原理”（众所周知，木桶的装水量受限于木桶最短的那块木板）；此外在考虑可用性的时候也要注意单点失效的问题，以免实际应用中因为小的错误导致整个系统不可用。</p>
<p>那么，让我们来看一下经过一番讨论之后，我们所期望的集群是什么样子的。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我们之所以花费大量的篇幅介绍集群的几个重要的体系结构概念，是因为这些概念构成了集群的最终整体。最后就让我们来看一下，综合了上述的方方面面后，我们可以得到以下几点关于集群的要素：</p>
<ul>
<li>独立的结点：每个节点是一台完整的计算机，一般是单一的系统。</li>
<li>单一系统映像能力：一个集群是一个单一的计算资源。集群将结点作为单独的资源，借助于单一系统映像技术，实现统一资源单一入口的概念。SSI使得集群更加易于使用和管理。</li>
<li>有效的结点间连接：集群中的结点，通常使用商品化网络，如以太网、FDDI或者光纤、ATM等等。此外，还使用标准的网络协议以建立进行节点间的通讯机制。这些都保证集群通信的有效进行。</li>
<li>增强的可用性：集群化提供了一个成本有效的方法以增加一个系统的可用性，比起主流的部件级容错产品，集群往往能够提供更合理的花费以达到效果。商用领域多数以加强系统的可用性为设计目标，因此可以使用集群中的技术加以实现。</li>
<li>更好的性能：平心而论，集群的诞生多少是因为性能驱动所促成的。在科学计算、工程应用、远程虚拟现实仿真等服务领域中，集群应该能够提供更高的性能，允许 将集群作为超级服务器使用，在最短的时间内完成原本单机系统无法顺利完成的任务，或者是提供巨大的磁盘和内存空间，实现那些”不可能的任务”。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/cluster-tech2-2.html" data-id="cji8sg1qv003340ioekvijs2d" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cluster-tech2-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/cluster-tech2-1.html" class="article-date">
  <time datetime="2014-10-16T02:59:39.000Z" itemprop="datePublished">2014-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiddleWare/">MiddleWare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/cluster-tech2-1.html">集群的可扩展性及其分布式体系结构（2）－上</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="体系结构的发展"><a href="#体系结构的发展" class="headerlink" title="体系结构的发展"></a>体系结构的发展</h2><p>过去的几十年里，计算机的发展经历了几代变更。从第一代的真空电子管和继电器存储器计算机到近年以ULSI（超大规模集成电路）为代表的第五代计算机。计 算机系统的速度在不断提高，造价和体积却不断减小。系统软件的发展虽然没有硬件系统那么令人瞩目，却也从汇编、机器语言的荒莽时代逐渐步入以跨平台、可扩 展、适合分布式计算的第五代编程语言体系。其最主要的代表就是Java，而最有前景的操作系统就是Linux和开放源码运动。今后的计算机系统将是具有更 强的能力，更友好的操作界面并借助互联网的分布式超级计算平台。</p>
<p>过去，人们普遍认为计算机性能的提高主要是因为生产出了更快更有效的处理器。这种观念受到了并行处理概念的挑战。分而治之的方法使得聚集（Cluster 的由来）的计算系统能够实现令人咂舌的计算能力。近年来昂贵而特制的并行超级计算机向集群的转换趋势越来越强，而高性能工作站标准化组件和网络部件的快速 发展成为促成这种转换的驱动因素。</p>
<h2 id="并行与可扩展"><a href="#并行与可扩展" class="headerlink" title="并行与可扩展"></a>并行与可扩展</h2><p>现代计算机的一个公共特点是并行性。不论是计算机的体系结构还是微处理器的发展方向来看，并行性逐渐体现在每一个可能见到的每一个角落。</p>
<p>x86体系微处理器的发展就是并行技术发展的一个很好的体现：多流水线、超标量设计都是提高CPU的并行能力的关键。而在集群的体系结构中，更是充分利用 了并行性这一特点。我们创建和使用并行计算机主要是为了解决单处理器的速度瓶颈，利用并行技术来提高应用性能（通过优化串行程序）。</p>
<p>另一个角度来看，因为并行技术的发展，也大大促进了计算机系统的可扩展性，同时在单位成本控制上也有了可喜的进步，使得基于集群的并行计算系统的性能价格比明显优于独立的计算机系统，比如小型机、和一般的大型主机</p>
<h2 id="何谓可扩展性"><a href="#何谓可扩展性" class="headerlink" title="何谓可扩展性"></a>何谓可扩展性</h2><p>如果能够通过增加资源以满足不断增长的对性能和功能的要求，或者是通过缩减资源，以降低成本，从涵盖硬件和软件的角度上讲，我们可以把符合这种特性的计算机系统称作是可扩展的。</p>
<p>可扩展并不是仅仅意味着体积的扩大、数量的增加，它也涵盖了缩减能力。目前日益多见的嵌入式系统就是很好的一个例子，它既是硬件体积、计算能力的缩减，又是软件的缩减（许多嵌入式操作系统往往通过剪裁而来）。因此，看待扩展问题需要从下面的几个观点入手：</p>
<ul>
<li><strong>功能性和性能：</strong>一个可扩展的系统应该能够提供更好的性能、更多的功能。系统的总体计算能力应该随着资源的增加而按照比例增展。理想的情况是，增长的速度是线性的。</li>
<li><strong>成本伸缩：</strong>另一方面讲，系统扩展的代价必须是合理的。粗略的标准是，成本的增加应该小于n或者nlogn的一个线性系数。但是结果往往不尽人意。因为在扩展计算系统的时候，不仅仅要做性能的考虑，而且还要考虑系统的可用性、稳定性等等，这些因素都会导致系统的总成本上升。</li>
<li><strong>可兼容性：</strong>包括硬件、系统软件和应用软件在内的组成部分。我们希望用户原有的程序 在不作变动或只作少量的变动后仍可以使用，要求用户购买一套全新的操作系统和重新开发他们的应用代码是不合适的。从部件上看，伸缩通常只涉及到系统的一部 分，如果添加更多的处理器或者是将现有的处理器升级到新的一代。新增加的部分应能够与系统的其余部分相兼容。这就是说，原有的存储器、磁盘、互联设备以及 外设仍然可以使用。</li>
</ul>
<h2 id="可扩展系统的意义"><a href="#可扩展系统的意义" class="headerlink" title="可扩展系统的意义"></a>可扩展系统的意义</h2><p>研究可扩展的系统，其主要动机在于寻求一个灵活的、成本可伸缩的计算系统架构方案。如这里的图所展示的，计算机种类在由销售量及性能和成本组成的坐标系统 中，形成一座金字塔。金字塔的顶部是那些能够提供万亿次以上性能的超级系统，他们把许多资源集成在一个看上去”单一”的系统中，采用顶尖的技术构造并行系 统，具有最高的性能。</p>
<h5 id="计算机分类金字塔"><a href="#计算机分类金字塔" class="headerlink" title="计算机分类金字塔"></a>计算机分类金字塔</h5><p><img src="http://www.ibm.com/developerworks/cn/linux/cluster/cluster_system/base/part2/fig1.gif" alt="计算机分类金字塔"></p>
<p>可扩展性通过它所提倡的公共的开放系统结构，包括了所有的计算机类。研究集群的可扩展体系结构，目的就是寻求一种可扩展的框架技术，使得上图中大型系统的高端技术能够不断应用于中低端的产品中，从而不断提高计算机的性能价格比水平。</p>
<p>像早期的Cray巨型机，当时在超级计算领域具有无可匹敌的地位，但是随着可扩展并行技术和商品化组件的发展，当年巨型机的地位逐渐被并行计算集群代替。 由于大部分集群都采用了标准化的商品组件，一方面可以充分享受部件性能的增长（CPU、网络、磁盘容量等都以近似摩尔定律的速度增长）；另一方面，在构架 上也具有很强的灵活性。比起专有的并行平台，以下的好处就显而易见了：</p>
<ul>
<li>因为单个工作站越来越强大，集群节点的计算能力也日益增强。而个人用户对于工作站的使用率往往很低，这样就有大量的闲置计算资源可以利用。</li>
<li>能够满足对不同性能和成本的要求。比如，用户可以在起初购买一个低端系统。当他对性能地要求增加时，他可以扩展此系统，而原有的软件和硬件部分仍然可以使用，充分保护了他原有的投资。</li>
<li>高端机可以使用低端机的部件以降低成本。例如，由于批量大、PC机使用的是低价的、市场销售的标准件。因为采用的是可扩展系统结构，故超级计算机也能使用 这些部件，从而可以降低系统成本。事实上，使用商品化部件：处理器、存储芯片、磁盘、I/O控制器等，已经成为高性能系统开发的趋势。</li>
<li>如果成本有效性能够随着生产技术的改进而增加的话，则为高端系统而开发的顶尖技术可能最终向金字塔下方移动，从而改进低端系统的性能。</li>
</ul>
<h2 id="可扩展性的三个考量"><a href="#可扩展性的三个考量" class="headerlink" title="可扩展性的三个考量"></a>可扩展性的三个考量</h2><p>可扩展性其本身是一个多方面的概念集合。包括了对计算资源可扩展的考量、对应用规模可扩展的考虑以及对技术换代可扩展三个方面的考虑。</p>
<h3 id="一、资源的可扩展性"><a href="#一、资源的可扩展性" class="headerlink" title="一、资源的可扩展性"></a>一、资源的可扩展性</h3><p>考虑资源可扩展性之前，首先要确定资源的真实含义是什么。</p>
<p>我们一般的都会把计算机硬件设备当作资源，比如CPU的数量、存储设备、IO设备等等。但从广义的角度理解，资源还应该包括软件，比如操作系统、应用软件等等。甚至，在日益复杂的互联网应用时代，资源的概念延伸到了用户需求的层次上。</p>
<p>因此对于提供服务的计算机系统来说，其支持为用户提供服务的一切软、硬件和其他配套的结构，都可以看作资源。因此如果我们从资源角度来考量可扩展性，就可 以把目标定义为：通过增加机器规模（既处理器数量）、投入更多的存储部件、升级软件甚至是改变系统的体系结构，从而使系统具有更好的性能或者功能。</p>
<p>扩展很容易让人联想到加强硬件设备，其中最明显的方法就是增加机器的处理器的数量。但是不是所有的机器都具备相同的可扩展能力。一个x86的SMP系统最多就只能扩展到64个CPU，；而一台IBM的SP2却可以扩展到最多512个CPU。</p>
<p>因此，扩大规模并不是简单的增加部件的数量就能解决问题的。通常，随着CPU数量的增加，包括RAM、总线带宽、网络等子系统也需要随之增加。所以，我们 常常看到，由于资源扩展所带来的技术上的障碍，仅仅是增加几个CPU或者其他部件，所花费的代价却远远高于增加的那些CPU本身的价值。那么，谨慎考虑扩 展规模所带来的性能价格比的增加，如何有效的利用更大并行性就是非常必要的了。这时，通过RAM的数量，扩展I/O速度，升级网络速度或者改造网络拓扑结 构反而能带来意想不到的效果。</p>
<p>另一方面，把软件也看作系统资源的话，就要涵盖很广的范围：可以升级新版本的操作系统，使他具有更多功能，支持更多线程、更大的地址空间，有更高效的内 核，能够识别更多的新硬件；也可以安装功能强大的中间件以扩展系统的特殊能力；还可以利用运行库来支持诸如消息传递、分布式事务处理等特性。扩展的方法不 一而足，也是在研究集群技术时主要考虑的问题。</p>
<h3 id="二、应用的可扩展性"><a href="#二、应用的可扩展性" class="headerlink" title="二、应用的可扩展性"></a>二、应用的可扩展性</h3><p>要充分扩展集群计算系统的能力，不仅资源是要可扩展的，应用程序也必须是可扩展的。这就是说，相同程序在一个可扩展系统上运行时，其性能随规模的扩大成正比例的改进。两个重要的考量是机器规模的可扩展性和问题规模的可扩展性。</p>
<p>首先从硬件的角度来考虑机器规模可扩展性这个问题。如果增加处理机的数量，我们系统的性能也会随之成比例地提高吗？假设有一个数据库服务器，处理银行每天 几十万的交易和1000万个用户的存款数据库，这样的情况下每秒钟该系统能够处理1000个在线事务。如果系统的处理器增加为原来的两倍，其他前提条件不 变，它能够提升到每秒2000个在线事务的处理速度吗？如果可以或者是接近的话，我们应当庆幸，该系统具有良好的可扩展性。当然，除了增加处理器的数量， 还可以是存储器或者I/O设备等等。</p>
<p>而考虑问题规模可扩展性这个角度则是以硬件环境的相对不变为基础的。如果仅仅是改变应用环境的工作负载，求解更大问题时，系统的性能表现又会如何。仍然以 上述的情况为例，如果数据库里的储户数据达到1亿个，每日处理的交易再上升一个数量级，那系统还能够保持每秒1000TPS的性能吗？</p>
<p>在研究应用可扩展问题的时候，我们将会发现：应用的限制最终无法通过简单的增加机器资源的方法加以突破。只有对应用程序本身和系统体系结构进行重大修改后，才能使用更多处理器和处理更多的问题。</p>
<p>我们应该将在一台特定机器上求解一个问题作为组合来加以考虑。有时将这种应用 / 机器对视为一个系统。如果更换应用或者更换软、硬件系统的体系结构，考虑可扩展的标准和角度就有很大的不同。</p>
<p>应用可扩展性不只依赖于处理器规模和问题规模。它也依赖于机器的存储器容量、I/O能力、以及通信能力。所有这些因素一起影响着可扩展性。我们将在今后的篇章讨论这些问题。</p>
<p>总的来说，考虑应用可扩展问题，需要从更加广义的角度上看，而不仅仅是上述的两个方面。那么我们就来看一下可扩展的另一个重要的方面–技术换代的可扩展性。</p>
<h3 id="三、技术换代的可扩展性"><a href="#三、技术换代的可扩展性" class="headerlink" title="三、技术换代的可扩展性"></a>三、技术换代的可扩展性</h3><p>技术换代可扩展性是局部概念而非全局概念。这里主要是指计算机系统能够随着技术的变更、换代，在保持原有的可用性基础上，通过”升级”部件的手段提高系统 的性能或者功能。这里的升级可能是我们常见的更换更高主频的CPU，也可能是增加系统的内存数量，还可能是升级操作系统到更新的版本。</p>
<p>其实这种事我们在WinTel时代常干，时不时换一下CPU或者内存什么的，但是不影响原来的系统应用，而且往往性能有很大的提升。</p>
<p>总的看来，计算机系统中CPU的发展速度最快，而内存的速度和单位容量的提升就慢一些，硬盘就会更慢（受到机械的限制），而最慢的就数程序设计语言了，到现在为止，我们都还在用类C编写关键的大型系统特别是集群系统应用。</p>
<p>并行系统的空间也是在扩展集群系统时的一个重要考量因素。新的设备是否能够容入原有的机箱内，扩展的需求是否能通过现有的互联技术得到满足，跨地域分布式技术的发展是否能给我们带来更大更强的系统，这些问题都缠绕在技术换代的思考过程中。</p>
<p>并行技术发展初期，系统大都是同构的，像具有完全一致内核的MPP系统，而集群也都是先在同构的框架下实现。而为了更好利用给各类的异构计算资源，势必需 要充分支持异构的并行集群。那么，异构可扩展性这一性质就反映了一个系统通过集成由不同设计者和厂商所提供的硬件和软件部分而进行扩展的能力。</p>
<p>异构扩展提倡使用具有标准、开放系统结构和接口的部件。在软件领域，我们也将它称为可移植性。追求异构可扩展性的代价是巨大的。除了借助标准协议和通讯平 台消除不同硬件系统之间的巨大差异，还要花费更多的资源处理现有应用的平滑移植。早期的COBOL应用在进行移植的时候就遇到很多问题，以至于现有的系统 中还存留大量的这种老式语言，也许Java集群出现会是解决这一问题的一个契机。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/cluster-tech2-1.html" data-id="cji8sg1qs002v40ioa4j3zwlq" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cluster-tech1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/cluster-tech1.html" class="article-date">
  <time datetime="2014-10-16T01:53:56.000Z" itemprop="datePublished">2014-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiddleWare/">MiddleWare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/cluster-tech1.html">集群的可扩展性及其分布式体系结构(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“话说天下大势，分久必合，合久必分”高端计算的体系结构发展正是遵循着这样一个规律。从金融、电信等大行业的数据集中处理到分布计算处理，再到二次集中和海量计算，趋势和应用显然是在变化，作为技术本身，分区和群集技术正是为适应不断变化的需要而产生的。</p>
<h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分 区技术初始于大型主机时代。企业级用户在购买大机后，许多应用都只使用大机的一小部分资源。这时，如果一个企业的生产部门只需要使用这台机器的10%的资 源，而且需要比较好的安全性，那么分区技术就能够满足它的要求，将主机的部分处理器和系统资源隔离出来，只利用这些资源组织计算系统，供生产部门使用，其 他的计算资源不受任何影响。这是早期的物理分区的概念。分区技术发展到今天，并不只为大型主机服务，因为分布式计算的应用在不断地扩展，在许多方面，高性 能的UNIX服务器和IA架构服务器已经在慢慢地取代大机的位置，分区这项技术在这些领域中也有着重要的作用。</p>
<p>分区带给人们的是更高的投资回报率和使用率，更加灵活的应用水平，以及动态地使用和分配资源。这些特点通过不同的分区种类来实现，目前分区的种类越来越 多，而且越来越细致，更倾向于客户的应用。最典型的分区技术就数我们在PC上使用的多操作系统了，这属于本地物理分区的范畴。而在多机环境中，通过分区可 以将不同”种群”的计算机分割开来（即使几台计算机位于同一个物理位置也可能服务于不同的”种群”），被分区的计算机还可以在不同的层面上复用，以提高计 算机系统的利用率。最常见的情况莫如VPN了，借助安全协议，VPN可以把分散的远程的计算机系统集合成一个逻辑上的”局域网”，协同完成复杂任务并保证 远程通信的安全；而这些计算机可能同那些物理上相近的计算机（比如同一个办公室）再次合并为一个机群，利用空闲时间完成另外一些实时性不高的计算任务。</p>
<h3 id="现在来讲讲”合”"><a href="#现在来讲讲”合”" class="headerlink" title="现在来讲讲”合”"></a>现在来讲讲”合”</h3><p>集 群技术是一种计算机系统之间连接的方式，运用它可以将分散的计算系统连接起来完成原来单独节点的计算系统无法完成的任务，最早的集群系统就是出于这样的并 行处理的目的出现的。但是随着计算机性能的发展和网络不安全因素的出现，系统的稳定性和可靠性是人们主要面临解决的问题。人们开始使用集群方式将两台以上 的设备连接起来，当整个集群系统中发生单点或者局部多点故障时，集群中其他的计算机将自动来接替出故障设备。最典型的例子就是实现双机热备份。两台一样的 计算机系统，使用集群软件连接起来，其中一台作为另一台的备份，当主机系统崩溃时，另一台来接替它的任务。除此以外，利用集群系统的高并行性能进行复杂的 科学、工程计算，也是非常有经济价值的做法。</p>
<p>对于集群系统来说，计算机的架构是一个非常重要的问题。同种架构的计算机之间，可以比较容易实现集群连接，一般来讲都是由厂商提供的集群软件。对于异构的 计算机系统，一般没有特别多的选择，目前类似JAVA的中间件技术可以解决部分跨平台的问题。集群技术可以有效地解决开放系统的稳定、抗压和负载平衡问 题。</p>
<h2 id="为什么需要集群"><a href="#为什么需要集群" class="headerlink" title="为什么需要集群"></a>为什么需要集群</h2><p>以往，企业用户在构建信息应用系统时只能在两种计算体系中进行选择，一是基于主机的计算体系，大体上采用的就是我们上面描述的分区方式；另一就是基于客户 机/服务器的群集型计算体系。基于主机的计算体系具有良好的系统可伸缩性、可靠性和高性能，但它昂贵的价格迫使用户在系统建设之初就在硬件系统上投入巨大 资源，而用户花费巨额资金购买的主机系统也许包含了不少并不需要的功能，造成资源浪费。基于客户机/服务器的群集型计算体系允许用户根据实际需要逐步增加 硬件系统，但这种体系的系统毕竟不是真正意义上的集群，缺乏必要的可用性和可管理性，在应用升级和管理方面都需要用户付出巨大的代价，每增加一个服务器/ 客户端的连接就要同时增加两端的管理负担。</p>
<p>因此，未来对计算速度、系统可靠性和成本实效性的要求必将促使发展另外的计算机模型来替代上述的计算模型。随着计算机网络的出现，一个新的具有更高性能/ 价格比的体系逐渐成为应用主流–分布式集群计算体系。当用户需要完成任何任务时，分布式集群计算提供了尽可能多的计算机处理能力和数据的透明访问能力， 同时实现高性能与高可靠性的目标。</p>
<p>集群计算模式是最经济的计算模式。集群系统允许用户把普通商用硬件系统组成机群，并根据需要随时在机群中增加新的硬件，提高系统的伸缩性和可用性，从而能 够在价格相对低廉的中低端平台上享用过去只有高端系统才具备的高可伸缩性和高可用性，既提高了系统的性能，同时也降低了成本,实现了更多的计算机=更快速 度的目标。</p>
<p>人们对集群计算的兴趣日益增加。集群计算的主题是多种多样的，许多研究人员正在研究有关分布式硬件体系结构和分布式系统软件设计的各方面问题以开发利用潜在的集群并行性和集群可用性。</p>
<p>集群计算系统（或叫做分布式系统）多种多样并涉及不同的系统体系结构。对一些用户来说，一个集群系统是为解决单个问题而紧密结合在一起工作的多处理机的集 合。对另一些用户来说，一个集群系统可能意味着一个由地理上分散的各自独立的处理机组成的计算机网络，这些处理机连接在一起以实现对不同资源的共享。</p>
<p>然而，集群这个词在计算机系统中被如此广泛应用以至于它的使用变得有点贬值。许多这方面的混乱来源于缺乏对物理的分布和逻辑的分布的区分。通过区分这两个概念，就可以更准确地描述一个分布式系统的属性。</p>
<p>对于分布式集群系统，我们使用以下 <strong>定义</strong>：在用户看来，一个集群系统是一个单一的普通系统，然而运行在一系列自治处理单元（PE也叫节 点）上的系统，每个处理单元（结点）有各自的物理内存空间并且并且通过高速链路或者标准商品化网络连接。结点间通过紧密的合作实现对同一任务的协同计算。 系统必须支持任意数量的进程和结点的动态扩展。</p>
<p>建立一个集群系统的主要目的在于：</p>
<ul>
<li>固有的应用得以保障。集群系统以一种很自然的方式开始存在，例如，在我们的社会中，人们常常以群体的形式出现并彼此共享信息，公司、社团、班级等等都是这 样的概念。在从个人计算向集群分布式计算迁移的时候，往往可以保留原有在个人计算系统上的应用，直接将原有的应用重新在新的集群系统中运行，并获得性能的 提升。这也是集群出现的一大原因。</li>
<li>性能/成本。集群系统的并行性降低了处理的瓶颈，提供了全面改进的性能，也就是说，集群系统提供了更好的性能价格比。</li>
<li>资源共享。集群系统能有效地支持不同位置的用户对信息和资源（硬件和软件）的共享。</li>
<li>灵活性和可扩展性。集群系统可以增量扩展，并能方便地修改或扩展系统以适应变化的环境而无需中断其运行。</li>
<li>实用性和容错性。依靠存储单元和处理单元的多重性，集群系统具有在系统出现故障的情况下继续运行的潜力。</li>
<li>可伸缩性。集群系统能容易地扩大以包括更多的资源（硬件和软件）。<br>最近，我们注意到，除了原有的以生产商用专有集群系统为主的厂商仍在发展自己的专有平台集群系统外，几个主要的硬件厂商都在研制并有计划推出基于 Linux的开放源码的集群产品，比如IBM、HP、SGI等等。开放源码界的迅猛发展为集群的出现提供良好的技术舞台，而向TurboLinux、 VALinux等老牌的Linux厂商更是把Linux集群这一高端应用领域作为自己的战略发展方向，不遗余力的加入激烈的市场产品竞争中。涌现在我们面 前的则是多种多样的可供选择的集群解决方案，有硬件的也有软件的。那么，如何借助开放源码届丰富的技术资源，实现一个优秀的集群系统呢？首先可以肯定的 是：一个优秀的集群系统不可能是一蹴而就的，需要仔细考虑用户的应用环境、业务需求、所能投入的成本还有技术的后继支援。下面，我们从集群技术方面一些比 较重要的功能来探讨一个优秀集群系统所应该具备的一些根本性的因素。而在此之前，我们先来看一个可能是最常见的小故事。</li>
</ul>
<h2 id="管理员的故事"><a href="#管理员的故事" class="headerlink" title="管理员的故事"></a>管理员的故事</h2><p>对于用户来说，怎样看待计算机系统和计算资源是因人而异的。特别是在群集应用环境中，不同的用户需求对资源的要求和侧重点也有所不同。</p>
<p>这里有一个故事，发生在一个被频繁访问的小门户站点。网站刚开始运行了一段时间后，情况良好，但是不久后管理员发现用户抱怨响应速度很低。于是，他升级了 服务器的CPU和磁盘系统，又加了512M的内存。心想，这会总不会有人再说什么了吧。可是，过了没多久，（当然，我们的这位站点很幸运的又吸引了大量的 用户，现在用户数量变成了原来的5倍），情况更糟糕了，在高峰期间有的访问甚至被站点拒绝。这是怎么回事呢？再升级吧，可硬件的升级似乎走到了尽头，我们 的管理员再次陷入困境。</p>
<p>这里，不幸的管理员遇到了系统瓶颈问题。通过查看日志，我们发现服务器CPU的负荷基本保持在10％左右（占用率），但是却有很多请求等待处理。是CPU 不够快吗，显然不是；是磁盘太慢吗，已经用了最快的RAID阵列，平均寻道时间到达5ms，不能再快了；内存不够大吗，主板所能支持的只有4G，已经到了 上限。所有的一切已经是极限，再升级下去只好更换到大型机了（那又会是一个无休止的投入）。站点每天仍要接受上百万次甚至上千万次的页面访问，怎么样才能 既控制服务器硬件成本又能大幅度提高性能呢？</p>
<p>固然，添加高速磁盘阵列可以减少寻道时间，提高响应的速度，或者，使用Cache技术能够加快页面访问效率。但是，一味地依靠扩展单一系统的硬件终究会有 上限，磁盘、内存、网络代宽的发展速度远远低于CPU的摩尔定律速度，造成彼此性能的互相牵制。而且，在单机系统种，越到高端的硬件，成本与性能比越是成 指数下降（见下图）。解决这样的问题，就有必要从体系结构入手，而不是简单的升级机器。</p>
<h5 id="单机系统性能-价格曲线"><a href="#单机系统性能-价格曲线" class="headerlink" title="单机系统性能/价格曲线"></a>单机系统性能/价格曲线</h5><p><img src="http://www.ibm.com/developerworks/cn/linux/cluster/cluster_system/base/part1/fig1.gif" alt="单机系统性能/价格曲线"></p>
<p>在上面的故事里。对于用户而言（指的是系统管理员和网站用户），服务器是提供web服务的资源，是若干计算、存储、数据的资源集合（查找数据、提供空 间）。用户关心的是你的站点的响应速度而非你用了多快的CPU多大的内存。因此，我们从用户的角度出发，不难发现，如何看待你的计算资源，是紧紧和使用者 的需求联系在一起的。那么，解决问题的关键就不是一些简单的数字层面上的思考了。沿着用户的需求–提高站点的响应速度，更确切的说缩短web站点响应每 个HTTP请求的时间�D�D是管理员首要解决的问题。</p>
<p>我们并不否认升级硬件的作用，但是我们知道，这样的情况下，仅仅依赖硬件的局部更换是不经济的做法。CPU由500MHz变成1GHz，web的性能不会就提升两倍，甚至毫不夸张的说，这种升级只能提高web性能10％左右。喔，太令人沮丧了～～。</p>
<p>那我们能不能反过来想呢，既然量变没有实质作用，那干脆就来个大改革。彻底改变服务器的体系结构。当然，要把花费的钞票控制在BOSS可以承受的范围内，钱是用来花的不是用来烧的。方案可能有：</p>
<ol>
<li>替换原有的系统，购买64位元服务器，比如SUN的Enterprise2000 ，不但CPU够劲，总线带宽也足够支撑严酷的应用环境考研，而且，千百万用户证实了：SUN就是我们”.COM”的那个至关重要的”点”。软硬件都没话说，那我们就买吧！</li>
</ol>
<p>呃～，等等，什么，你再说一遍，一台Enterprise要我XX万大洋！？原有的ASP要重写！！？？请一个管理员维护费要~~！！！</p>
<p>我已经听不下去了，更何况掏腰包的人。更换系统就意味着投资、投资、再投资，更要命的是，原来的东西怎么办？扔掉？留着也没用。</p>
<p>更换系统的硬件平台显然不是解决问题的好办法，那么，在原有的基础上扩展系统呢？于是，有了下面的这种方法：</p>
<ol>
<li>利用免费的集群软件，在保留原有的硬件投资基础上，添加几台新的PC设备，组建负载均衡集群系统。既然一台机器解决不了问题，那就让多台机器一起分担吧。怎么做呢？</li>
</ol>
<p>第一步：安装Linux或者BSD操作系统，由于拥有广大的开放源码届的大力支持，你无须担心缺少优秀应用程序。无论你是在怎样应用环境中，开放源码团体总能为你提供合适的稳定的软件。</p>
<p>第二步：安装相应的Kernel和有关的系统补丁。并且安装和你的kernel匹配的集群软件包。比较常见的有LVS、LSF、MOSIX等。都可以很好 满足负载均衡的要求。其中LVS由于其基于Netfilter技术，具有很好的可扩展性和性能表现，受到广大开发者的青睐。</p>
<p>第三步：配置你的负载均衡集群系统。无非就是配置一些脚本文件。大多数的集群配置文件都是直接可编辑的，文法简单，编好即用，非常方便。</p>
<p>第四步：配置你的集群服务软件。这里的服务软件特指那些提供实际网络服务的应用程序。其实一般都是WEB SERVER或者Mail Server。故事中是一个Web站点，我们就弄个Apache吧。不管你是静态文本还是CGI，Apache都能够帮助你实现平滑的Web移植。如果你 不幸使用了ASP这样的专有技术，你还可以考虑诸iASP这样的第三方插件来实现移植。一般来说，对于PHP、JSP和CGI，Apache都能支持的很 好。</p>
<p>第五步：适当设定你的数据中心。其实这一步对于集群系统来说非常重要。因为由单台服务器转向分布式的集群结构，数据的存储一致问题就凸现而出。如果WEB 应用集中于数据库访问，那么可以使用集中的数据库服务器，Progresql或者Mysql甚至是Oracle都行，其本身对于数据的一致、安全、性能都 有保障。或者，可以考虑使用NFS、AFS等分布式文件系统来共享集群各结点的存储空间和应用数据。</p>
<p>最后一步：写一份报告。告诉你的BOSS你不但顺利解决了站点的瓶颈问题，而且大大大减轻了他花钱升级的痛苦（实际上，除了购买廉价服务器的费用，其他基本上没有什么花费）。说不定吝啬的BOSS还会涨你的工资呢～嘿嘿。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>故事讲完，不知各位看官有何感想。其实集群技术并不是实验室的阳春白雪，也不是老教授闭门造车的产物。集群技术”和我们的国计民生，老百姓的生活有密切的关系” ；）。我们看到，适当的应用集群技术，不但具有明显的经济效益（很多用户就是冲着省钱而来），而且在性能、可用性、稳定性等诸多方面，具有很强的可扩展性。是计算体系近年来发展的主要方向。</p>
<p>研究集群技术，需要从多个方面着手，多角度的考虑集群系统。如果从上述的资源的角度考虑集群，就要注意用户是需要什么样的计算资源，是计算能力呢还是响应 速度，或者是可用性；如果从硬件构架看，就有工作站集群（COW）、大规模并行处理机（MPP）、对称多处理机（SMP）、分布式异构计算集群（典型是 GRID）；如果从应用领域看，既有侧重于科学和工程计算的并行计算集群，也有侧重于作业负载的负载平衡集群，或者是广泛应用于严格商用环境的高可用容错 集群；还有考虑集群的时候重点研究的几个方面：可用性、单一系统映像（SSI）、作业管理、调度、 通信等等。可以说，孤立的从某一个角度或者某一个方面看集群，是无法真正了解集群的原理，准确的评估集群的各方面能力、性能，更别说为应用需求选择合适的 集群环境了。了解集群，就得先从体系结构的设计和可扩展性开始。</p>
<p>&nbsp;</p>
<p>作者：林凡</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/cluster-tech1.html" data-id="cji8sg1qt002z40ioy07t1gnj" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-synchronized" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java-synchronized.html" class="article-date">
  <time datetime="2014-10-15T06:45:42.000Z" itemprop="datePublished">2014-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java-synchronized.html">Java synchronized详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p># </p>
<div id="cnblogs_post_body"><br><br><span style="font-size: 14pt;"><strong><span style="color: #0000ff;">第一篇：</span></strong></span><br><br><strong><span style="color: #0000ff;">使用synchronized</span>
</strong><br><br>在编写一个类时，如果该类中的代码可能运行于多线程环境下，那么就要考虑同步的问题。在Java中内置了语言级的同步原语 －－synchronized，这也大大简化了Java中多线程同步的使用。我们首先编写一个非常简单的多线程的程序，是模拟银行中的多个线程同时对同一 个储蓄账户进行存款、取款操作的。<br>在程序中我们使用了一个简化版本的Account类，代表了一个银行账户的信息。在主程序中我们首先生成了 1000个线程，然后启动它们，每一个线程都对John的账户进行存100元，然后马上又取出100元。这样，对于John的账户来说，最终账户的余额应 该是还是1000元才对。然而运行的结果却超出我们的想像，首先来看看我们的演示代码：<br><div><br><div><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">class Account {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    String name;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    float amount;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    public Account(String name, float amount) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        this.name = name;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        this.amount = amount;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    public  void deposit(float amt) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        float tmp = amount;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        tmp += amt;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        try {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            Thread.sleep(100);//模拟其它处理所需要的时间，比如刷新数据库等<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        } catch (InterruptedException e) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            // ignore<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        amount = tmp;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    public  void withdraw(float amt) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        float tmp = amount;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        tmp -= amt;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        try {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            Thread.sleep(100);//模拟其它处理所需要的时间，比如刷新数据库等<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        } catch (InterruptedException e) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            // ignore<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        amount = tmp;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    public float getBalance() {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        return amount;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">}<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">public class AccountTest{<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    private static int NUM_OF_THREAD = 1000;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    static Thread[] threads = new Thread[NUM_OF_THREAD];<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    public static void main(String[] args){<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        final Account acc = new Account(“John”, 1000.0f);<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        for (int i = 0; i&lt; NUM_OF_THREAD; i++) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            threads[i] = new Thread(new Runnable() {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">                public void run() {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">                        acc.deposit(100.0f);<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">                        acc.withdraw(100.0f);<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">                }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            });<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            threads[i].start();<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        for (int i=0; i&lt;NUM_OF_THREAD; i++){<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            try {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">                threads[i].join(); //等待所有线程运行结束<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            } catch (InterruptedException e) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">                // ignore<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        System.out.println(“Finally, John’s balance is:” + acc.getBalance());<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">}<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""></div><br></div><br>注意，上面在Account的deposit和withdraw方法中之所以要把对amount的运算使用一个临时变量首先存 储，sleep一段时间，然后，再赋值给amount，是为了模拟真实运行时的情况。因为在真实系统中，账户信息肯定是存储在持久媒介中，比如RDBMS 中，此处的睡眠的时间相当于比较耗时的数据库操作，最后把临时变量tmp的值赋值给amount相当于把amount的改动写入数据库中。运行 AccountTest，结果如下（每一次结果都会不同）：<br><br>E:\java\exer\bin&gt;java AccountTest<br>Finally, John’s balance is:3900.0<br><br>E:\java\exer\bin&gt;java AccountTest<br>Finally, John’s balance is:4900.0<br><br>E:\java\exer\bin&gt;java AccountTest<br>Finally, John’s balance is:4700.0<br><br>E:\java\exer\bin&gt;java AccountTest<br>Finally, John’s balance is:3900.0<br><br>E:\java\exer\bin&gt;java AccountTest<br>Finally, John’s balance is:3900.0<br><br>E:\java\exer\bin&gt;java AccountTest<br>Finally, John’s balance is:5200.0<br><br>为 什么会出现这样的问题？这就是多线程中的同步的问题。在我们的程序中，Account中的amount会同时被多个线程所访问，这就是一个竞争资源，通常 称作竞态条件。对于这样的多个线程共享的资源我们必须进行同步，以避免一个线程的改动被另一个线程所覆盖。在我们这个程序中，Account中的 amount是一个竞态条件，所以所有对amount的修改访问都要进行同步，我们将deposit()和withdraw()方法进行同步，修改为：<br><div><br><div><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">  public synchronized void deposit(float amt) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        float tmp = amount;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        tmp += amt;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        try {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            Thread.sleep(1);//模拟其它处理所需要的时间，比如刷新数据库等<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        } catch (InterruptedException e) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            // ignore<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        amount = tmp;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    public synchronized void withdraw(float amt) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        float tmp = amount;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        tmp -= amt;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        try {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            Thread.sleep(1);//模拟其它处理所需要的时间，比如刷新数据库等<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        } catch (InterruptedException e) {<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">            // ignore<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""><br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">        amount = tmp;<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt="">    }<br><img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" alt=""></div><br></div><br>此时，再运行，我们就能够得到正确的结果了。Account中的getBalance()也访问了amount，为什么不对getBalance()同步呢？因为getBalance()并不会修改amount的值，所以，同时多个线程对它访问不会造成数据的混乱。<br><br>&nbsp;<br><br><strong><span style="color: #0000ff;">同步加锁的是对象，而不是代码。</span></strong><br><br>因此，如果你的类中有一个同步方法，这个方法可以被两个不同的线程同时执行，只要每个线程自己创建一个的该类的实例即可。<br><br>&nbsp;<br><br>参考下面的代码：<br><br>class Foo extends Thread<br>{<br>private int val;<br>public Foo(int v)<br>{<br>val = v;<br>}<br>public synchronized void printVal(int v)<br>{<br>while(true)<br>System.out.println(v);<br>}<br>public void run()<br>{<br>printVal(val);<br>}<br>}<br>class SyncTest<br>{<br>public static void main(String args[])<br>{<br>Foo f1 = new Foo(1);<br>f1.start();<br>Foo f2 = new Foo(3);<br>f2.start();<br>}<br>}<br><br>运行SyncTest产生的输出是1和3交叉的。如果printVal是断面，你看到的输出只能是1或者只能是3而不能是两者同时出现。程序运行的结果证明两个线程都在并发的执行printVal方法，即使该方法是同步的并且由于是一个无限循环而没有终止。<br><br><span style="color: #0000ff;"><strong>类的同步：</strong></span><br><br>要实现真正的断面，你必须同步一个全局对象或者对类进行同步。下面的代码给出了一个这样的范例。<br><br>class Foo extends Thread<br>{<br>private int val;<br>public Foo(int v)<br>{<br>val = v;<br>}<br>public void printVal(int v)<br>{<br>synchronized(Foo.class) {<br>while(true)<br>System.out.println(v);<br>}<br>}<br>public void run()<br>{<br>printVal(val);<br>}<br>}<br><br>上面的类不再对个别的类实例同步而是对类进行同步。对于类Foo而言，它只有唯一的类定义，两个线程在相同的锁上同步，因此只有一个线程可以执行printVal方法。<br><br>这个代码也可以通过对公共对象加锁。例如给Foo添加一个静态成员。两个方法都可以同步这个对象而达到线程安全。<br><br>面笔者给出一个参考实现，给出同步公共对象的两种通常方法：<br><br>1、<br><br>class Foo extends Thread<br>{<br>private int val;<br>private static Object lock=new Object();<br>public Foo(int v)<br>{<br>val = v;<br>}<br>public void printVal(int v)<br>{<br>synchronized(lock) {<br>while(true)<br>System.out.println(v);<br>}<br>}<br>public void run()<br>{<br>printVal(val);<br>}<br>}<br><br>上面的这个例子比原文给出的例子要好一些，因为原文中的加锁是针对类定义的，一个类只能有一个类定义，而同步的一般原理是应该尽量减小同步的粒度以到达更好的性能。笔者给出的范例的同步粒度比原文的要小。<br><br>2、<br><br>class Foo extends Thread<br>{<br>private String name;<br>private String val;<br>public Foo(String name,String v)<br>{<br>this.name=name;<br>val = v;<br>}<br>public void printVal()<br>{<br>synchronized(val) {<br>while(true) System.out.println(name+val);<br>}<br>}<br>public void run()<br>{<br>printVal();<br>}<br>}<br>public class SyncMethodTest<br>{<br>public static void main(String args[])<br>{<br>Foo f1 = new Foo(“Foo 1:”,”printVal”);<br>f1.start();<br>Foo f2 = new Foo(“Foo 2:”,”printVal”);<br>f2.start();<br>}<br>}<br><br>上面这个代码需要进行一些额外的说明，因为JVM有一种优化机制，因为String类型的对象是不可变的，因此当你使用””的形式引用字符串 时，如果JVM发现内存已经有一个这样的对象，那么它就使用那个对象而不再生成一个新的String对象，这样是为了减小内存的使用。<br><br>上面的main方法其实等同于：<br><br>public static void main(String args[])<br>{<br>String value=”printVal”;<br>Foo f1 = new Foo(“Foo 1:”,value);<br>f1.start();<br>Foo f2 = new Foo(“Foo 2:”,value);<br>f2.start();<br>}<br><br><span style="color: #0000ff;"><strong> </strong></span><br><br><strong><span style="color: #0000ff;">总结：</span></strong><br><br>1、synchronized关键字的作用域有二种：<br>1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线 程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的 synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；<br>2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。<br><br>2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象；<br><br>3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；<br><br>Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。<br><br>一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。<br><br>二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。<br><br>三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。<br><br>四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。<br><br>五、以上规则对其它对象锁同样适用.<br><br>&nbsp;<br><br><strong><span style="font-size: 14pt; color: #0000ff;">第二篇：</span></strong><br><br>synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。<br>1. synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：<br>public synchronized void accessVal(int newVal);<br>synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能<br><br>执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行<br><br>状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有<br><br>一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）<br><br>。<br>在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成<br><br>员变量的访问。<br>synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为<br><br>synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可<br><br>以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供<br><br>了更好的解决办法，那就是 synchronized 块。<br>2. synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下：<br>synchronized(syncObject) {<br>//允许访问控制的代码<br>}<br>synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机<br><br>制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。<br>对synchronized(this)的一些理解<br>一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线<br><br>程必须等待当前线程执行完这个代码块以后才能执行该代码块。<br>二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized<br><br>(this)同步代码块。<br>三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)<br><br>同步代码块的访问将被阻塞。<br>四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个<br><br>object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。<br>五、以上规则对其它对象锁同样适用<br><span style="font-size: 14pt; color: #0000ff;"><strong>第三篇：</strong></span><br><br>打个比方：一个object就像一个大房子，大门永远打开。房子里有 很多房间（也就是方法）。<br><br>这些房间有上锁的（synchronized方法）， 和不上锁之分（普通方法）。房门口放着一把钥匙（key），这把钥匙可以打开所有上锁的房间。<br><br>另外我把所有想调用该对象方法的线程比喻成想进入这房子某个 房间的人。所有的东西就这么多了，下面我们看看这些东西之间如何作用的。<br><br>在此我们先来明确一下我们的前提条件。该对象至少有一个synchronized方法，否则这个key还有啥意义。当然也就不会有我们的这个主题了。<br><br>一个人想进入某间上了锁的房间，他来到房子门口，看见钥匙在那儿（说明暂时还没有其他人要使用上锁的 房间）。于是他走上去拿到了钥匙<br><br>，并且按照自己 的计划使用那些房间。注意一点，他每次使用完一次上锁的房间后会马上把钥匙还回去。即使他要连续使用两间上锁的房间，<br><br>中间他也要把钥匙还回去，再取回来。<br><br>因此，普通情况下钥匙的使用原则是：“随用随借，用完即还。”<br><br>这时其他人可以不受限制的使用那些不上锁的房间，一个人用一间可以，两个人用一间也可以，没限制。但是如果当某个人想要进入上锁的房<br><br>间，他就要跑到大门口去看看了。有钥匙当然拿了就走，没有的话，就只能等了。<br><br>要是很多人在等这把钥匙，等钥匙还回来以后，谁会优先得到钥匙？Not guaranteed。象前面例子里那个想连续使用两个上锁房间的家伙，他<br><br>中间还钥匙的时候如果还有其他人在等钥匙，那么没有任何保证这家伙能再次拿到。 （JAVA规范在很多地方都明确说明不保证，象<br><br>Thread.sleep()休息后多久会返回运行，相同优先权的线程那个首先被执行，当要访问对象的锁被 释放后处于等待池的多个线程哪个会优先得<br><br>到，等等。我想最终的决定权是在JVM，之所以不保证，就是因为JVM在做出上述决定的时候，绝不是简简单单根据 一个条件来做出判断，而是<br><br>根据很多条。而由于判断条件太多，如果说出来可能会影响JAVA的推广，也可能是因为知识产权保护的原因吧。SUN给了个不保证 就混过去了<br><br>。无可厚非。但我相信这些不确定，并非完全不确定。因为计算机这东西本身就是按指令运行的。即使看起来很随机的现象，其实都是有规律<br><br>可寻。学过 计算机的都知道，计算机里随机数的学名是伪随机数，是人运用一定的方法写出来的，看上去随机罢了。另外，或许是因为要想弄<br><br>的确定太费事，也没多大意义，所 以不确定就不确定了吧。）<br><br>再来看看同步代码块。和同步方法有小小的不同。<br><br>1.从尺寸上讲，同步代码块比同步方法小。你可以把同步代码块看成是没上锁房间里的一块用带锁的屏风隔开的空间。<br><br>2.同步代码块还可以人为的指定获得某个其它对象的key。就像是指定用哪一把钥匙才能开这个屏风的锁，你可以用本房的钥匙；你也可以指定<br><br>用另一个房子的钥匙才能开，这样的话，你要跑到另一栋房子那儿把那个钥匙拿来，并用那个房子的钥匙来打开这个房子的带锁的屏风。<br><br>记住你获得的那另一栋房子的钥匙，并不影响其他人进入那栋房子没有锁的房间。<br><br>为什么要使用同步代码块呢？我想应该是这样的：首先对程序来讲同步的部分很影响运行效率，而一个方法通常是先创建一些局部变<br><br>量，再对这些变量做一些 操作，如运算，显示等等；而同步所覆盖的代码越多，对效率的影响就越严重。因此我们通常尽量缩小其影响范围。<br><br>如何做？同步代码块。我们只把一个方法中该同 步的地方同步，比如运算。<br><br>另外，同步代码块可以指定钥匙这一特点有个额外的好处，是可以在一定时期内霸占某个对象的key。还记得前面说过普通情况下钥<br><br>匙的使用原则吗。现在不是普通情况了。你所取得的那把钥匙不是永远不还，而是在退出同步代码块时才还。<br><br>还用前面那个想连续用两个上锁房间的家伙打比方。怎样才能在用完一间以后，继续使用另一间呢。用同步代码块吧。先创建另外<br><br>一个线程，做一个同步代码 块，把那个代码块的锁指向这个房子的钥匙。然后启动那个线程。只要你能在进入那个代码块时抓到这房子的钥匙<br><br>，你就可以一直保留到退出那个代码块。也就是说 你甚至可以对本房内所有上锁的房间遍历，甚至再sleep(10<em>60</em>1000)，而房门口却还有<br><br>1000个线程在等这把钥匙呢。很过瘾吧。<br><br>在此对sleep()方法和钥匙的关联性讲一下。一个线程在拿到key后，且没有完成同步的内容时，如果被强制sleep()了，那key还一<br><br>直在 它那儿。直到它再次运行，做完所有同步内容，才会归还key。记住，那家伙只是干活干累了，去休息一下，他并没干完他要干的事。为<br><br>了避免别人进入那个房间 把里面搞的一团糟，即使在睡觉的时候他也要把那唯一的钥匙戴在身上。<br><br>最后，也许有人会问，为什么要一把钥匙通开，而不是一个钥匙一个门呢？我想这纯粹是因为复杂性问题。一个钥匙一个门当然更<br><br>安全，但是会牵扯好多问题。钥匙 的产生，保管，获得，归还等等。其复杂性有可能随同步方法的增加呈几何级数增加，严重影响效率。这也<br><br>算是一个权衡的问题吧。为了增加一点点安全性，导致效 率大大降低，是多么不可取啊。<br><br>synchronized的一个简单例子<br><br>public class TextThread {<br><br>public static void main(String[] args) {<br>TxtThread tt = new TxtThread();<br>new Thread(tt).start();<br>new Thread(tt).start();<br>new Thread(tt).start();<br>new Thread(tt).start();<br>}<br>}<br><br>class TxtThread implements Runnable {<br>int num = 100;<br>String str = new String();<br><br>public void run() {<br>synchronized (str) {<br>while (num &gt; 0) {<br><br>try {<br>Thread.sleep(1);<br>} catch (Exception e) {<br>e.getMessage();<br>}<br>System.out.println(Thread.currentThread().getName()<br>+ “this is “ + num–);<br>}<br>}<br>}<br>}<br><br>上面的例子中为了制造一个时间差,也就是出错的机会,使用了Thread.sleep(10)<br><br>Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如<br><br>何？――还得对synchronized关键字的作用进行深入了解才可定论。<br><br>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，<br><br>synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。<br><br>在进一步阐述之前，我们需要明确几点：<br><br>A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其<br><br>他线程的对象访问。<br><br>B．每个对象只有一个锁（lock）与之相关联。<br><br>C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。<br><br>接着来讨论synchronized用到不同地方对代码产生的影响：<br><br>假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。<br><br>1． 把synchronized当作函数修饰符时，示例代码如下：<br><br>Public synchronized void methodAAA()<br><br>{<br><br>//….<br><br>}<br><br>这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中<br><br>执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了<br><br>synchronized关键字的方法。<br><br>上边的示例代码等同于如下代码：<br><br>public void methodAAA()<br><br>{<br><br>synchronized (this)      // (1)<br><br>{<br><br>//…..<br><br>}<br><br>}<br><br>(1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个<br><br>拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造<br><br>成数据混乱：（<br><br>2．同步块，示例代码如下：<br><br>public void method3(SomeObject so)<br><br>{<br><br>synchronized(so)<br><br>{<br>//…..<br>}<br><br>}<br><br>这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明<br><br>确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：<br><br>class Foo implements Runnable<br><br>{<br><br>private byte[] lock = new byte[0]; // 特殊的instance变量<br><br>Public void methodA()<br>{<br><br>synchronized(lock) { //… }<br><br>}<br><br>//…..<br><br>}<br><br>注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock<br><br>= new Object()则需要7行操作码。<br><br>3．将synchronized作用于static 函数，示例代码如下：<br><br>Class Foo<br>{<br><br>public synchronized static void methodAAA()   // 同步的static 函数<br>{<br>//….<br>}<br><br>public void methodBBB()<br>{<br><br>synchronized(Foo.class)   // class literal(类名称字面常量)<br><br>}<br>}<br><br>代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这<br><br>个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。<br><br>记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的<br><br>目的。P1指的是由Foo类产生的对象。<br><br>可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj<br><br>在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。<br><br>小结如下：<br><br>搞清楚synchronized锁定的是哪个对象，就能帮助我们设计更安全的多线程程序。<br><br>还有一些技巧可以让我们对共享资源的同步访问更加安全：<br><br>1． 定义private 的instance变量+它的 get方法，而不要定义public/protected的instance变量。如果将变量定义为public，对象在外界可以<br><br>绕过同步方法的控制而直接取得它，并改动它。这也是JavaBean的标准实现方式之一。<br><br>2． 如果instance变量是一个对象，如数组或ArrayList什么的，那上述方法仍然不安全，因为当外界对象通过get方法拿到这个instance对象<br><br>的引用后，又将其指向另一个对象，那么这个private变量也就变了，岂不是很危险。 这个时候就需要将get方法也加上synchronized同步，并<br><br>且，只返回这个private对象的clone()――这样，调用端得到的就是对象副本的引用了<br><br></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/java-synchronized.html" data-id="cji8sg1sh006c40io945w9rxs" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/11/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MiddleWare/">MiddleWare</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OperatingSystem/">OperatingSystem</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Program/">Program</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Salesforce/">Salesforce</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日本/">日本</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apex/">Apex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB2/">DB2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IBM/">IBM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IT/">IT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SFDC/">SFDC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOA/">SOA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Salesforce/">Salesforce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SalesforceExam/">SalesforceExam</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SalesforceTest/">SalesforceTest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SalesforceXyTools/">SalesforceXyTools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aix/">aix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cloud/">cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eclipse/">eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ecshop/">ecshop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ilmt/">ilmt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jython/">jython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vba/">vba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/">vmware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/was/">was</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websphere/">websphere</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wordpress/">wordpress</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信/">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库优化/">数据库优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日本/">日本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试，test/">测试，test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/理论/">理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Apex/" style="font-size: 14.17px;">Apex</a> <a href="/tags/DB2/" style="font-size: 10.83px;">DB2</a> <a href="/tags/Database/" style="font-size: 14.17px;">Database</a> <a href="/tags/IBM/" style="font-size: 11.67px;">IBM</a> <a href="/tags/IT/" style="font-size: 12.5px;">IT</a> <a href="/tags/SFDC/" style="font-size: 14.17px;">SFDC</a> <a href="/tags/SOA/" style="font-size: 10.83px;">SOA</a> <a href="/tags/Salesforce/" style="font-size: 20px;">Salesforce</a> <a href="/tags/SalesforceExam/" style="font-size: 10px;">SalesforceExam</a> <a href="/tags/SalesforceTest/" style="font-size: 10px;">SalesforceTest</a> <a href="/tags/SalesforceXyTools/" style="font-size: 15.83px;">SalesforceXyTools</a> <a href="/tags/aix/" style="font-size: 11.67px;">aix</a> <a href="/tags/android/" style="font-size: 14.17px;">android</a> <a href="/tags/apache/" style="font-size: 10px;">apache</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/cloud/" style="font-size: 10px;">cloud</a> <a href="/tags/eclipse/" style="font-size: 10.83px;">eclipse</a> <a href="/tags/ecshop/" style="font-size: 11.67px;">ecshop</a> <a href="/tags/ilmt/" style="font-size: 12.5px;">ilmt</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/jython/" style="font-size: 10px;">jython</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/mq/" style="font-size: 10px;">mq</a> <a href="/tags/mysql/" style="font-size: 14.17px;">mysql</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/php/" style="font-size: 18.33px;">php</a> <a href="/tags/python/" style="font-size: 10.83px;">python</a> <a href="/tags/shell/" style="font-size: 10.83px;">shell</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/vba/" style="font-size: 10.83px;">vba</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/was/" style="font-size: 15px;">was</a> <a href="/tags/websphere/" style="font-size: 10px;">websphere</a> <a href="/tags/windows/" style="font-size: 14.17px;">windows</a> <a href="/tags/wordpress/" style="font-size: 16.67px;">wordpress</a> <a href="/tags/分布式/" style="font-size: 13.33px;">分布式</a> <a href="/tags/微信/" style="font-size: 10.83px;">微信</a> <a href="/tags/数据库/" style="font-size: 10.83px;">数据库</a> <a href="/tags/数据库优化/" style="font-size: 10.83px;">数据库优化</a> <a href="/tags/日本/" style="font-size: 10.83px;">日本</a> <a href="/tags/测试，test/" style="font-size: 10px;">测试，test</a> <a href="/tags/理论/" style="font-size: 19.17px;">理论</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2001/01/">January 2001</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2000/01/">January 2000</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hello-world.html">Hello World</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-ApexCreator.html">SalesforceXyTools Sublime ApexCreator</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-ExportToExcel.html">SalesforceXyTools Sublime Export SObject To Excel</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-TestCodeCreator.html">SalesforceXyTools Sublime Test Code Creator</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-Install.html">SalesforceXyTools Sublime Install Help</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
      邮箱：exia.sfdc@outlook.com<br />
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Exia.Huang<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>