<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Exia.Huang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Exia.Huang">
<meta property="og:url" content="http://www.ibmer.info/page/11/index.html">
<meta property="og:site_name" content="Exia.Huang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Exia.Huang">
  
    <link rel="alternate" href="/atom.xml" title="Exia.Huang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Exia.Huang</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.ibmer.info"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-session-distribute" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/session-distribute.html" class="article-date">
  <time datetime="2014-10-15T04:56:01.000Z" itemprop="datePublished">2014-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/session-distribute.html">关于Session的分布式存储和容灾问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div>引子：一般对session的分布式管理常用的有以下3中方式，当然必须是当访问用户达到一定的量级以后才有分布式Session的概念</div><br><div>1）集群分组</div><br><div>2）一致性哈希</div><br><div>3）放置前端cookie中</div><br><div></div><br><div><strong>首先说说集群分组：</strong></div><br><div><br><br><em>   一般一组memcache支持3000个并发，如果10组就是30000个并发， 你想瞬间30000个并发是什么感念，每天几亿的Pv不是问题。
</em>   组内memcached服务器数量可配（一般2~4台）通过内存共享的方式对client来说就是一块内存，其实是几台memcached服务台的合集。<br></div><br><div>容灾备份：重要的东西可以在memcached攒够了一个阀值，统一备份一次放到文件中或者数据库中，这样在一台服务器死掉后可以去数据库拿数据放在另外一台服务器上（这个有点耗时）</div><br><div>对于这个备份有比较成熟的解决方案，比如靠sina的开源插件，memcachedb这个 可以把 memcached数据缓存到 伯克利db里面  ）</div><br><div></div><br><div><strong>一致性哈希：</strong></div><br><div>这个比较普遍了，我以前的公司采用的就是这个办法。具体算法如下：</div><br><div></div><br><div>解释：其实是这样的，我们把所有的sessionId从前端用户请求cookie中拿到 做getHashCode（sessionId）=key1，多个sessionId就是keyn。。。。，在用一直的哈希算法后得到的key永远在一个 0~2的32次方内的定值，sessionID不同，这个key也就不同，这样在0到2的32次方的数可以组成一个闭环，在把我们的memcached服 务器也采用统一的hash算法一般是getHashCode（memcached ID地址）这样是不是服务器的key也落到这个闭环里面了，呵呵，从0开始向右，或者向左都行，一般是向右开始找key找到一个key就放到离他最近的一 个服务器的key中，这样在2个node之间的key就可以放在右侧的node服务器中。怎么知道key是sessionID算出来的，还是 memcached IP地址算出来的呢，哈哈，大家自己想想，别想的太复杂啊。</div><br><div></div><br><div><strong>放置前端cookie中：</strong></div><br><div>这个也比较简单，就是将用户的登陆成功信息放在cookie中，并设置一个失效时间，当用户请求web服务器时，这个请求会经过一个策略，这个策略会看cookie里面的信息，</div><br><div>如果发现已经登陆了，则将cookie里面的信息提出来用户用户基本信息展示，并给出已登录界面。</div><br><div>如果发现未登陆，直接给出登录界面。</div><br><div>这个方法就是有些浏览器对cookie的大小是有限制的，所有要将你放入cookie尽可能的小，bool型的用0,1表示，字符串编码成数字最好。</div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/session-distribute.html" data-id="cji8sg1vg00bx40io92jhzd3q" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jvm-structure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/jvm-structure.html" class="article-date">
  <time datetime="2014-10-15T04:41:23.000Z" itemprop="datePublished">2014-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/jvm-structure.html">jvm的内部体系结构浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jvm全称是Java Virtual Machine(java虚拟机)。它之所以被称之为是“虚拟”的，就是因为它仅仅是由一个规范来定义的抽象计算机。我们平时经常使用的Sun HotSpot虚拟机只是其中一个具体的实现(另外还有BEA JRockit、IBM J9等等虚拟机)。在实际的计算机上通过软件来实现一个虚拟计算机。与VMWare等类似软件不同，你是看不到jvm的，它存在于内存。</p>
<p>当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果在同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。</p>
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图1所示。</p>
<p><a href="/images/wp-uploads/2014/10/jvm-struct.jpg"><img src="/images/wp-uploads/2014/10/jvm-struct.jpg" alt="jvm-struct"></a></p>
<p>&nbsp;</p>
<p>下面先对图中各部分做个简单的说明：</p>
<p>1.class文件：虚拟机并不关心Class的来源是什么语言，只要它符合Java class文件格式就可以在Java虚拟机中运行。使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的 编译器一样可以把程序代码编译成Class文件。</p>
<p>2.类装载器子系统：负责查找并装载Class 文件到内存，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>3.方法区：在类装载器加载class文件到内存的过程中，虚拟机会提取其中的类型信息，并 将这些信息存储到方法区。方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。由于所有线程都共享方法区，因此它们对 方法区数据的访问必须被设计为是线程安全的。</p>
<p>4.堆：存储Java程序创建的类实例。所有线程共享，因此设计程序时也要考虑到多线程访问对象(堆数据)的同步问题。</p>
<p>5.Java栈：Java栈是线程私有的。每当启动一个新线程时，Java虚拟机都会为它分 配一个Java栈。Java栈以帧为单位保存线程的运行状态。虚拟机只会直接对Java栈执行两种操作：以帧为单位的压栈或出栈。当线程调用java方法 时，虚拟机压入一个新的栈帧到该线程的java栈中。当方法返回时，这个栈帧被从java栈中弹出并抛弃。一个栈帧包含一个java方法的调用状态，它存 储有局部变量表、操作栈、动态链接、方法出口等信息。</p>
<p> 6.程序计数器：一个运行中的Java程序，每当启动一个新线程时，都会为这个新线程创建 一个自己的PC(程序计数器)寄存器。程序计数器的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来 选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法， 这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空(Undefined)。</p>
<p>7.本地方法栈：本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。<span style="font-family: SimSun;">任何本地方法接口都会使用某种本地方法栈。当线程调用</span>Java<span style="font-family: SimSun;">方法时，虚拟机会创建一个新的栈帧并压入</span>Java<span style="font-family: SimSun;">栈。然而当它调用的是本地方法时，虚拟机会保持</span>Java<span style="font-family: SimSun;">栈不变，不再在线程的</span>Java<span style="font-family: SimSun;">栈中压入新的帧，虚拟机只是简单地动态链接并直接调用指定的本地方法。</span><span style="font-family: SimSun;">如果某个虚拟机实现的本地方法接口是使用</span>C<span style="font-family: SimSun;">连接模型的话，那么它的本地方法栈就是</span>C<span style="font-family: SimSun;">栈。</span></p>
<p><span style="font-family: SimSun;">8.<span style="font-family: SimSun;">执行引擎</span>： 负责执行字节码。方法的字节码是由Java虚拟机的指令序列构成的。每一条指令包含一个单字节的操作码，后面跟随0个或多个操作数。执行引擎执行字节码 时，首先取得一个操作码，如果操作码有操作数，取得它的操作数。它执行操作码和跟随的操作数规定的动作，然后再取得下一个操作码。这个执行字节码的过程在 线程完成前将一直持续。<br></span></p>
<p>&nbsp;</p>
<p>相关的参考资料:</p>
<p>1.深入Java虚拟机(原书第2版)</p>
<p>2.深入理解Java虚拟机:JVM高级特性与最佳实践</p>
<p>3.互联网相关的文章</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/jvm-structure.html" data-id="cji8sg1sp006t40iobp9l38mg" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jvm-theory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/jvm-theory.html" class="article-date">
  <time datetime="2014-10-15T04:20:16.000Z" itemprop="datePublished">2014-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/jvm-theory.html">jvm的工作原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JVM在整个jdk中处于最底层,负责于操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也就虚拟计算机. 操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.</p>
<p>1.创建JVM装载环境和配置</p>
<p>2.装载JVM.dll</p>
<p>3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例</p>
<p>4.调用JNIEnv实例装载并处理class类。</p>
<p>&nbsp;</p>
<p><strong>一．JVM装入环境，JVM提供的方式是操作系统的动态连接文件．</strong>既然是文件那就一个装入路径的问题，Java 是怎么找这个路径的呢？当你在调用Java test的时候，操作系统会在path下在你的Java.exe程序，Java.exe就通过下面一个过程来确定JVM的路径和相关的参数配置了．下面基 于Windows的实现的分析．</p>
<p>首先查找jre路径，Java是通过GetApplicationHome api来获得当前的Java.exe绝对路径，c:\j2sdk1.4.2_09\bin\Java.exe,那么它会截取到绝对路径c: \j2sdk1.4.2_09\，判断c:\j2sdk1.4.2_09\bin\Java.dll文件是否存在，如果存在就把c: \j2sdk1.4.2_09\作为jre路径，如果不存在则判断c:\j2sdk1.4.2_09\jre\bin\Java.dll是否存在，如果存 在这c:\j2sdk1.4.2_09\jre作为jre路径．如果不存在调用GetPublicJREHome查HKEY_LOCAL_MACHINE \Software\JavaSoft\Java Runtime Environment\“当前JRE版本号”\JavaHome的路径为jre路径。</p>
<p>然后装载JVM.cfg文件JRE路径+\lib+\ARCH（CPU构架）+\JVM.cfgARCH（CPU构架）的判断是通过 Java_md.c中GetArch函数判断的，该函数中windows平台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。以我的 为例：C:\j2sdk1.4.2_09\jre\lib\i386\JVM.cfg.主要的内容如下：</p>
<ol>
<li>-client KNOWN</li>
<li>-server KNOWN</li>
<li>-hotspot ALIASED_TO -client</li>
<li>-classic WARN</li>
<li>-native ERROR</li>
<li>-green ERROR<br>在我们的jdk目录中jre\bin\server和jre\bin\client都有JVM.dll文件存在，而Java正是通过JVM.cfg 配置文件来管理这些不同版本的JVM.dll的．通过文件我们可以定义目前jdk中支持那些JVM,前面部分（client）是JVM名称，后面是参 数，KNOWN表示JVM存在，ALIASED_TO表示给别的JVM取一个别名，WARN表示不存在时找一个JVM替代，ERROR表示不存在抛出异 常．在运行Java XXX是，Java.exe会通过CheckJVMType来检查当前的JVM类型，Java可以通过两种参数的方式来指定具体的JVM类型，一种按照 JVM.cfg文件中的JVM名称指定，第二种方法是直接指定，它们执行的方法分别是“Java -J”、“Java -XXaltJVM=”或“Java -J-XXaltJVM=”。如果是第一种参数传递方式，CheckJVMType函数会取参数‘-J’后面的JVM名称，然后从已知的JVM配置参数中 查找如果找到同名的则去掉该JVM名称前的‘-’直接返回该值；而第二种方法，会直接返回“-XXaltJVM=”或“-J-XXaltJVM=”后面的 JVM类型名称；如果在运行Java时未指定上面两种方法中的任一一种参数，CheckJVMType会取配置文件中第一个配置中的JVM名称，去掉名称 前面的‘-’返回该值。CheckJVMType函数的这个返回值会在下面的函数中汇同jre路径组合成JVM.dll的绝对路径。如果没有指定这会使用 JVM.cfg中第一个定义的JVM.可以通过set _Java_LAUNCHER_DEBUG=1在控制台上测试．</li>
</ol>
<p>最后获得JVM.dll的路径，JRE路径+\bin+\JVM类型字符串+\JVM.dll就是JVM的文件路径了，但是如果在调用Java程序时用-XXaltJVM=参数指定的路径path,就直接用path+\JVM.dll文件做为JVM.dll的文件路径．</p>
<p><strong>二：装载JVM.dll</strong></p>
<p>通过第一步已经找到了JVM的路径，Java通过LoadJavaVM来装入JVM.dll文件．装入工作很简单就是调用Windows API函数：</p>
<p>LoadLibrary装载JVM.dll动态连接库．然后把JVM.dll中的导出函数JNI_CreateJavaVM和 JNI_GetDefaultJavaVMInitArgs挂接到InvocationFunctions变量的CreateJavaVM和 GetDefaultJavaVMInitArgs函数指针变量上。JVM.dll的装载工作宣告完成。</p>
<p><strong>三：初始化JVM，获得本地调用接口，</strong>这样就可以在Java中调用JVM的函数了．调用InvocationFunctions－&gt;CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例．</p>
<p><strong>四：运行Java程序．</strong></p>
<p>Java程序有两种方式一种是jar包，一种是class. 运行jar,Java -jar XXX.jar运行的时候，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用Java类 Java.util.jar.JarFileJNIEnv中方法getManifest()并从返回的Manifest对象中取 getAttributes(“Main-Class”)的值即jar包中文件：META-INF/MANIFEST.MF指定的Main-Class的 主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。main 函数直接调用Java.c中LoadClass方法装载该类。如果是执行class方法。main函数直接调用Java.c中LoadClass方法装载 该类。</p>
<p>然后main函数调用JNIEnv实例的GetStaticMethodID方法查找装载的class主类中</p>
<p>“public static void main(String[] args)”方法，并判断该方法是否为public方法，然后调用JNIEnv实例的</p>
<p>CallStaticVoidMethod方法调用该Java类的main方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/jvm-theory.html" data-id="cji8sg1sr006x40iokwmuhkld" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-transaction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/spring-transaction.html" class="article-date">
  <time datetime="2014-10-15T04:13:48.000Z" itemprop="datePublished">2014-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/spring-transaction.html">Spring的事务配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。</p>
<p>DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用Hibernate进行数据访问 时，DataSource实际为SessionFactory，TransactionManager的实现为 HibernateTransactionManager。</p>
<p><a href="/images/wp-uploads/2014/10/spring-transaction.jpg"><img src="/images/wp-uploads/2014/10/spring-transaction.jpg" alt="spring-transaction"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/spring-transaction.html" data-id="cji8sg1w200d340io70g61k1e" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-12306" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/12306.html" class="article-date">
  <time datetime="2014-10-14T14:39:55.000Z" itemprop="datePublished">2014-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/12306.html">12306铁路购票系统设计的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1 今年春节期间铁路客流量据说有31亿<br>2 目前12306 pv是14亿，而高峰期就在8点到10点，那么也就是有可能在这两个小时里有5亿访问量，而每秒的并发量估计在最高峰时能达到几千万<br>3 目前Ngix能处理在线1万，但是实际值一般是8000左右<br>4 一台IBM大型机要几千万美元，估计加上DB2，交易中间件，得小1亿了<br>5 腾讯，淘宝等拥有总在线人数4亿规模或者事务处理达到亿级别的规模耗时七八年，总投资估计上百亿 （腾讯资料：1亿在线背后的技术挑战）</p>
<p>6 绝对不能两个人订到同一张票，而看到有票，而点击了下订单又说没票了这种失误是可以容忍的。</p>
<p>&nbsp;</p>
<p>假设一个车次能坐1000人，有10万个人想订这车次的这个时间的票，那么意味着这10万人要被分别负载到10台机器上，这10台机器要共同去维护这1000张票的余量。简单的分库分表大家都会，但是可能是有成千上万台机器来处理这些用户，而且这些用户还可以订全国的火车票。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>我想到了一些机制来处理，或者说先简化再处理问题：</p>
<p>总原则：不需要所有的人</p>
<p>1 职责分离，将登录，订票（查询，填表，下定单），支付，查订单，查车票等都分成不同的服务，采用不同的集群（服务）去处理。</p>
<p>2 登录系统，只要有足够的服务器，大家都可以登录进来，这个十分简单</p>
<p>3 订票，总原则是 让能够进入订票流程的人，快速无障碍的进入系统，设定15分钟为一个阀值，15分钟内成功下订单，则将其踢出订票系统，用户可以拿着订单号通过电话或者登录支付系统进行支付（Apple的网上商店即这样），超过15分钟没搞定的也被踢出，提示操作超时。点击订票之后，进入前置分析机，分析机负责计算背后的机器能负载多少用户下订单。比如目前有1百万人同时点击了订票，而背后只能负载10万人，那么出现一个随机摇号程序，摇出10万人，其他人返回 “系统繁忙，稍后重试”的提示。这10万人被负载在10台机器上，可以进行查询，当点击指定车票（标记为ClickSelectedTicket）后，根据车票被分散到不同的机器上（其实是MapRe<span style="text-decoration: underline;">du</span>ce的思想）。比如有1万人被定位到要订票T1，系统扔出900张T1票，留100张容错（随着系统逐步稳定，可减少容错票数），然后大家抢锁，采用乐观离线锁。在最终提交订单时检测</p>
<p>4 可以采用地铁高峰限流的方式（其实Apple购买iphone时也类似），就是增加到达ClickSelectedTicket之后的页面的路径，可以多绕几圈，最终减少并发可能性。</p>
<p>5 采用token机制保障页面必须从第一步点击订票开始进入，不可以绕过中间步骤。以免刷票机器人对系统造成冲击（当然还要做IP限定）</p>
<p>6 将票分到几台服务器上，将购买到该车次该时间车票则将身份证+车次+座位+时间作为key，这样验证是否此人已经订过该票一步搞定，然后异步统计余票。某台机器的票没有了，这台机器就被移除（类似于负载均衡原理，票没了就相当于机器挂了，目前常用的技术是心跳，还是异步统计）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>还需考虑的问题是：一个座位分段卖出问题。各个铁路局分布式提供车票的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/12306.html" data-id="cji8sg1ok000240iorssxe50w" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-session-memcached" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/session-memcached.html" class="article-date">
  <time datetime="2014-10-14T14:33:20.000Z" itemprop="datePublished">2014-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/session-memcached.html">分布式系统开发常见问题-1. session的复制与共享 2. 分布式缓存的设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>session的复制与共享</li>
</ol>
<p>在web应用中，为了应对大规模访问,必须实现应用的集群部署.要实现集群部署主要需要实现session共享机制,使得多台应用服务器之间会话统一, tomcat等多数主流web服务器都采用了session复制以及实现session的共享. 但问题还是很明显的：</p>
<p>在节点持续增多的情况下,session复制带来的性能损失会快速增加.特别是当session中保存了较大的对象,而且对象变化较快时,性能下降更加显著.这种特性使得web应用的水平扩展受到了限制.</p>
<p>&nbsp;</p>
<p>session共享的另一种思路就是把session集中起来管理,首先想到的是采用数据库来集中存储session,但数据库是文件存储相对内存慢了一个数量级,同时这势必加大数据库系统的负担.所以需要一种既速度快又能远程集中存储的服务：memcached</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>使用memcached来存储session有两种方案:</p>
<p>(1)直接通过tomcat6的扩展机制实现.</p>
<p>Reference: <a href="http://www.javaeye.com/topic/81641" target="_blank" rel="external"><span style="color: #108ac6;">http://www.javaeye.com/topic/81641</span></a></p>
<p>(2)通过自己编写filter实现.</p>
<p>考虑到系统的扩展,我们采用这种方案.这样可以使session共享机制和中间件脱钩.</p>
<p>Reference: <a href="http://www.javaeye.com/topic/82565" target="_blank" rel="external"><span style="color: #108ac6;">http://www.javaeye.com/topic/82565</span></a></p>
<p>主要思路:</p>
<p>1)继承重构<strong>HttpServletRequestWrapper</strong>,<strong>HttpSessionWrapper</strong>类,覆盖原来和session存取相关的方法呢,都通过SessionService类来实现.</p>
<p>2)使用filter拦截cookie中的sessionId,通过sessionId构造新的HttpServletRequestWrapper对象,传给后面的应用.</p>
<p>3)SessionService连接memcached服务,以sessionId作为key,存取的对象是一个map.map的内容即为session的内容.</p>
<p>&nbsp;</p>
<p>使用过程注意几个问题和改进思路：<br>1、memcache的内存应该足够大，这样不会出现用户session从Cache中被清除的问题(可以关闭memcached的对象退出机制)。<br>2、如果session的读取比写入要多很多，可以在memcache前再加一个Oscache等本地缓存，减少对memcache的读操作，从而减小网络开销，提高性能。<br>3、如果用户非常多，可以使用memcached组，通过set方法中带hashCode，插入到某个memcached服务器</p>
<p>&nbsp;</p>
<p>(3)使用memcached-session-manager管理session</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/session-memcached.html" data-id="cji8sg1vi00c140iobe9bnt2u" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sed-example" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/sed-example.html" class="article-date">
  <time datetime="2014-10-14T04:32:58.000Z" itemprop="datePublished">2014-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OperatingSystem/">OperatingSystem</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/sed-example.html">sed,awk,grep,cut,find 实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.find / -type f -user logread -ls &gt;/dev/null<br>查找用户logread所有的普通文件并输出至屏幕；<br>2.find . -name “<em>.java” -mtime -2<br>查找当前目录下最近2天修改的java文件；<br>3.grep -in exp file<br>在file文件中搜索exp字符串，不区分大小写并显示行号(-c,只显示行数；-l,只显示文件名)；<br>4.grep -e “^0” file(grep -e “g$” file)<br>在file文件中搜索以0开头的行，或者以g结束的行。grep命令支持ERE，如grep -E ‘(x1|x2)x3’ file，搜索匹配x1x3或x2x3模式的行；<br>5.sed -n ‘/exp1/, /exp2/p’ file<br>在file文件中搜索与exp1,exp2模式匹配的之间的行数据；<br>6.sed -n ‘/exp1/w file1<br>&gt; /exp2/w file2<br>&gt; ‘ file<br>在file文件中搜索与exp1匹配的行，写入到file1文件中，搜索与exp2匹配的行，写入到file2文件中。也可以指定行，如sed -n ‘1,7w file1<br>&gt; 8,$w file2’ file，将file文件的1-7行写入到file1中，8-末尾行写入到file2中；<br>7.sed ‘4i\<br>string1\<br>&gt; string2<br>&gt; ‘ file<br>在file文件中第4行前插入string1和string2两行；<br>8.sed ‘a\<br>exp1\<br>exp2<br>‘ file<br>在file文件中每行后追加两行exp1和exp2；<br>9.sed ‘/^[ ]</em>$/d’ file<br>在file文件中删除空行，[]中包含a space and a tab；<br>10.sed ‘s/exp1/exp2/g’ file<br>将file文件中所有匹配exp1模式的字符串替换为匹配exp2模式的字符串。sed ‘s/^/exp1/‘ file，sed ‘s/$/exp1/‘ file，将file文件每行开头或者结束的地方插入exp1。sed还支持记忆模式，支持IRE；<br>11.awk -F”|” ‘ { print $NF}’ file<br>输出file每行最后一个字段的内容<br>awk用于格式化报文或者从文件中抽取数据包．<br>1.$awk ‘{print $0}’ gefforey.txt | tee gefforey.doc<br>该命令将在屏幕输出gefforey.txt文件内容并将其内容复制到gefforey.doc文件中．<br>2.$awk -F: ‘{print $1}’ gefforey.log<br>该命令以:为单位读取gefforey.log文件中第一列内容．<br>３.$awk ‘BEGIN {print “Name   Belt\n————“} {print $1”\t”$3}’ gefforey.txt<br>该命令将在屏幕首先输出”Name   Belt”，第二行输出”————“，并在输出文件内容的时候，每列之间间隔一个TAB位．可以在print语句之后加上END {print “end of output”}，那么将会在文件内容输出结束的时候打印”end of output”．<br>4.$awk ‘$2 ~ /^baidu$/ {print $0}’ gefforey.txt<br>该命令显示gefforey.txt文件中以空格分隔的第二列字符串是”baidu”的所有行．<br>5.$awk ‘{if($2 ~ /^baidu$/) print $0}’ gefforey.txt<br>该命令判断如果某行第二列字符串为”baidu”,则打印出该行．<br>6.$awk ‘{if($2 &lt; $3) print $0}’ gefforey.txt<br>该命令显示判断如果某行第二列值小于第三列值，则打印该行．awk的条件操作符有：<br>&lt; 小于，&gt; = 大于等于，&lt; = 小于等于，~ 匹配正则表达式，= = 等于，!~ 不匹配正则表达式，!= 不等于<br>7.$awk ‘{if($2 ==”google1” &amp;&amp; $3==”google2”) print $0}’ gefforey.txt<br>该命令判断如果某行第二列值为”google1”并且第三列值为”google2”，则打印出该行．awk的逻辑表达式有：&amp;&amp; AND，|| O R，! 非．<br>8.$awk ‘{print NF,NR,$0} END{print FILENAME}’ gefforey.txt<br>该命令会输出浏览记录的域个数和已读的记录数，并在输出结尾打印文件名．awk内置的变量有：<br>A R G C 命令行参数个数<br>A R G V 命令行参数排列<br>E N V I R O N 支持队列中系统环境变量的使用<br>FILENAME a w k浏览的文件名<br>F N R 浏览文件的记录数<br>F S 设置输入域分隔符，等价于命令行- F选项<br>N F 浏览记录的域个数<br>N R 已读的记录数<br>O F S 输出域分隔符<br>O R S 输出记录分隔符<br>R S 控制记录分隔符<br>（附：1.N F的一个强大功能是将变量$ P W D的返回值传入a w k并显示其目录。这里需要指定域分隔<br>符/．命令为：echo $PWD | awk -F/ ‘{print $NF}’;<br>2.显示文件名，命令为：echo “/usr/local/etc/rc.sybase” | awk -F/ ‘{print $NF}’．<br>9.$awk ‘{name=$1; belt=$3;if(belt ~ /yellow/) print name “is belt” belt }’ gefforey.txt<br>该命令将第一列的值赋给变量name,第三行的值赋给变量belt，并打印语句．awk允许在语句中进行赋值操作，赋值操作符有：=， +=， *=， / =， %=， ^ = ．<br>10.$awk ‘gsub(/111/,222) {print $0}’ gefforey.txt<br>该命令将文件中所有包含111的数字替换为222，awk的内置函数有：<br>g s u b ( r, s ) 在整个$ 0中用s替代r<br>g s u b ( r, s , t ) 在整个t中用s替代r<br>i n d e x ( s , t ) 返回s中字符串t的第一位置<br>l e n g t h ( s ) 返回s长度<br>m a t c h ( s , r ) 测试s是否包含匹配r的字符串<br>s p l i t ( s , a , f s ) 在f s上将s分成序列a<br>s p r i n t ( f m t , e x p ) 返回经f m t格式化后的e x p<br>s u b ( r, s ) 用$ 0中最左边最长的子串代替s<br>s u b s t r ( s , p ) 返回字符串s中从p开始的后缀部分<br>s u b s t r ( s , p , n ) 返回字符串s中从p开始长度为n的后缀部分<br>g s u b函数有点类似于s e d查找和替换。它允许替换一个字符串或字符为另一个字符串或字<br>符，并以正则表达式的形式执行。第一个函数作用于记录$ 0，第二个g s u b函数允许指定目标，<br>然而，如果未指定目标，缺省为$ 0。<br>i n d e x（s，t）函数返回目标字符串s中查询字符串t的首位置。l e n g t h函数返回字符串s字符<br>长度。m a t c h函数测试字符串s是否包含一个正则表达式r定义的匹配。s p l i t使用域分隔符f s将<br>字符串s划分为指定序列a。s p r i n t函数类似于p r i n t f函数（以后涉及），返回基本输出格式f m t的<br>结果字符串e x p。s u b（r，s）函数将用s替代$ 0中最左边最长的子串，该子串被（ r）匹配。<br>s u b（s，p）返回字符串s在位置p后的后缀。s u b s t r（s，p，n）同上，并指定子串长度为n。<br>11.$echo “65” | awk ‘{printf “//%c\n”,$0}’<br>该命令管道输出65到awk，并观察其ASCII字符．awk的printf函数格式如下：<br>% c A S C I I字符<br>% d 整数<br>% e 浮点数，科学记数法<br>% f 浮点数，例如（1 2 3 . 4 4）<br>% g a w k决定使用哪种浮点数转换e或者f<br>% o 八进制数<br>% s 字符串<br>% x 十六进制数</p>
<p>awk命令也许是linux系统中最为复杂的命令，需要好好的练习！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/sed-example.html" data-id="cji8sg1vb00bn40iows2makit" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aix/">aix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell/">shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sed-awk-grep-cut-find" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/sed-awk-grep-cut-find.html" class="article-date">
  <time datetime="2014-10-14T02:20:55.000Z" itemprop="datePublished">2014-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OperatingSystem/">OperatingSystem</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/sed-awk-grep-cut-find.html">Linux下sed,awk,grep,cut,find等常用命令介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">Linux文件查找命令find,xargs</div><br><div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">find命令的格式：</div><br><div style="margin: 10px 0px 20px; padding: 6px 8px; border: 1px dashed #788856; font-size: 14px; color: #000000; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 26.600000381469727px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; overflow: auto; background: #f5f5f5;"><br><pre style="font-family: 'Courier New', Courier, monospace; font-size: 12px;">find pathname -options [-print -exec -ok …]</pre><br></div><br><div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">find 命令的参数：</div>

<p><strong>-perm
</strong></p>
<p>按照文件权限模式查找<br>读权限：r:4 写权限：w:2 执行权限：x:1<br>文件属主具有读、写权限： rw：4+2=6<br>其他用户具有读权限：r:4</p>
<p><strong><br>-type
</strong></p>
<p>查找的文件类型<br>-type f 文件<br>-type d 目录<br>-type l 符号链接文件</p>
<p><strong><br>-exec
</strong></p>
<p>-exec 参数后面跟的是 command命令<br>command命令的终止，使用 ‘;’ (分号）来判定，在后面必须有一个 ‘;’<br>‘{}’，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于command命令进行处理<br>对于不同的系统，直接使用分号可能会有不同的意义， 使用转义符 ‘\’在分号前明确说明</p>
<p><strong><br>xargs
</strong></p>
<p>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">sed</div><br><div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">sed简介：</div>

<p>sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<p>sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">关于sed的hold space（内存缓冲区）和pattern space(模式空间)</div>

<p>sed在处理文件的时候，每一行都需要存放在一个叫“模式空间”的临时缓存区。每处理完一行，便清理一次(pattern space)，并把下一行再次放入该临时缓冲区。</p>
<p>而保留空间(hole space),是当sed用到h命令的时候，把匹配的模式放在一个叫做”hold buffer”的保留缓冲里，但需要使用G(sed的取得命令）的时候，sed 从这个保留空间(hold space)中取得。</p>
<p>sed 是以行为单位进行读取,读取后的内容存放在pattern space。</p>
<p>holding space是通过h,H,x,g,G命令和pattern space产生关连,利用这5个特性可以辅助pattern space解决问题。</p>
<p><strong><br>g
</strong></p>
<p>表示行内全面替换,当前处理行进行全局替换。</p>
<p><strong><br>G
</strong></p>
<p>获得内存缓冲区的内容，并追加到当前模板块文本的后面。<br>函数参数G 与g 唯一差别是, sed执行g 时, 数据盖掉(overwrite) pattern space 内原来的数据<br>而G , 数据则是”添加(append)” 在pattern space 原来数据后。</p>
<p><strong><br>‘;’号
</strong></p>
<p>如果在一行中有多个命令，要用分号隔开。</p>
<p><strong><br>s/re/string
</strong></p>
<p>用string替换正则表达式re。</p>
<p><strong><br>d
</strong></p>
<p>从模板块（Pattern space）位置删除行。</p>
<p>函数参数d 表示删除数据行, 其指令格式如下:<br>[address1[ ,address2]] d</p>
<p>对上述格式有下面几点说明:<br>函数参数d 最多与两个地址参数配合。</p>
<p>sed执行删除动作情况如下:<br>将pattern space 内符合地址参数的数据删除。<br>将下一笔资料读进pattern space 。<br>重新执行sedscript。<br><strong>n**</strong><br>**</p>
<p>读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</p>
<p>函数参数n 表示读入下一行资料。<br>其指令格式如下:<br>[address1[ ,address2]] n<br>对上述格式有下面几点说明:<br>函数参数n 最多配合两个地址参数。</p>
<p>sed执行读入下一行动作的情况如下:<br>输出在pattern space 的数据。<br>将下一笔资料读到pattern space。<br>执行下一个编辑指令。</p>
<p><strong><br>-n, –quiet, –silent
</strong></p>
<p>安静模式，取消默认输出。</p>
<p><strong><br>x
</strong></p>
<p>交换pattern和hold space</p>
<p><strong><br>p
</strong></p>
<p>打印模式空间的行，通常 p 会与参数 sed -n 一起使用</p>
<p><strong><br>N
</strong></p>
<p>追加下一行数据到模式空间，数据行间以换行字符(embedded newline character)分隔。</p>
<p>函数参数N 表示添加下一笔资料在pattern space 内。<br>其指令格式如下:<br>[address1 ,[address2]] N<br>对上述格式有下面几点说明:<br>函数参数N 最多配合两个地址参数。</p>
<p>sed执行时, 将下一行数据读入并添加在pattern space 内, 数据行间以换行字符(embedded newline character)分隔。<br>此外, 在替换时, 换行字符可用\n 来match。</p>
<p><strong><br>**</strong>=<strong>**
</strong></p>
<p>打印当前行号</p>
<p><strong><br>.
</strong></p>
<p>匹配一个非换行符的字符</p>
<p><strong><br>h
</strong></p>
<p>拷贝模板块的内容到内存中的缓冲区。</p>
<p><strong><br>!
</strong></p>
<p>表示后面的命令对所有没有被选定的行发生作用。</p>
<p><strong><br>$
</strong></p>
<p>锚定行的结束 如：/sed$/匹配所有以sed结尾的行。也可以表示文件最后一行。</p>
<p><strong><br>1
</strong></p>
<p>表示文件第一行</p>
<p><strong><br>-e
</strong></p>
<p>直接在指令列模式上进行 sed 的动作编辑，允许多台编辑。</p>
<p><strong><br>:label
</strong></p>
<p>表示建立一个标签label</p>
<p><strong><br>b
</strong></p>
<p>跳转命令，这个命令是无条件跳转<br>ba表示跳转到标签a处</p>
<p><strong><br>q
</strong></p>
<p>退出Sed。</p>
<p><strong><br>D
</strong></p>
<p>删除模板块的第一行。</p>
<p>函数参数D 与d 的比较如下:<br>当pattern space 内只有一数据行时, D 与d 作用相同。<br>当pattern space 内有多行资料行时D 表示只删除pattern space 内第一行资料; d 则全删除。<br>D 表示执行删除后, pattern space 内不添加下一笔数据, 而将剩下的数据重新执行sedscript ; d 则读入下一行后执行sedscript。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">grep</div><br><div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">grep简介：</div>

<p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。Unix的grep家族包括grep、 egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是 fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux 使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p>
<p><strong><br>-l
</strong></p>
<p>打印匹配模板的文件清单</p>
<p><strong><br>-r
</strong></p>
<p>递归地搜索目录。在缺省情况下，按照到目录的链接。</p>
<p><strong><br>^
</strong></p>
<p>锚定行的开始</p>
<p><strong><br>[^]
</strong></p>
<p>匹配一个不在指定范围内的字符</p>
<p><strong><br>\w
</strong></p>
<p>匹配文字和数字字符，也就是[A-Za-z0-9]</p>
<p><strong><br>x{m,}
</strong></p>
<p>重复字符x,至少m次，如：’o{5,}‘匹配至少有5个o的行。<br>‘\w{3,}‘即是至少有4个字符的已登录用户</p>
<p><strong><br>$
</strong></p>
<p>锚定行的结束 如：/sed$/匹配所有以sed结尾的行。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">awk</div><br><div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">关于awk:</div>

<p>awk是一种用于处理文本的编程语言工具。AWK 实用工具的语言在很多方面类似于 shell 编程语言，尽管 AWK 具有完全属于其本身的语法。在最初创造 AWK 时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定 内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">awk命令的语法</div>

<p>awk ‘{pattern + action}’ {filenames}</p>
<p>其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号 ({}) 不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">$0，关于awk的字段</div>

<p>实用工具将每个输入行分为记录和字段。记录是单行的输入，而每条记录包含若干字段。默认的字段分隔符是空格或制表符，而记录的分隔符是换行。虽然在默认情况下将制表符和空格都看作字段分隔符（多个空格仍然作为一个分隔符），但是可以将分隔符从空格改为任何其它字符。</p>
<p>当 AWK 读取输入内容时，整条记录被分配给变量 $0。每个字段以字段分隔符分开，被分配给变量 $1、$2、$3 等等。一行在本质上可以包含无数个字段，通过字段号来访问每个字段。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">BEGIN和END</div>

<p>在awk 中两个特别的表达式，BEGIN和END，这两者都可用于pattern中，提供BEGIN和END的作用是给程序赋予初始状态和在程序结束之后执行一些扫尾的工作。任何在BEGIN之后列出的操作（在{}内）将在awk开始扫描输入之前执行，而END之后列出的操作将在扫描完全部的输入之后执行。因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">gsub（r，s，t）</div>

<p>在字符串t中用字符串s和正则表达式r匹配的所有字符串。返回值是替换的个数。如果没有给出t，默认是$0。</p>
<p><strong><br>NR
</strong></p>
<p>表示awk开始执行程序后所读取的数据行数.</p>
<p><strong><br>$0
</strong></p>
<p>表示当前处理的整行数据</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">Linux的cut命令</div><br><div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">关于cut命令：</div>

<p>cut命令可以从一个文本文件或者文本流中提取文本列，具体的说就是在文件中负责剪切数据用的。cut是以每一行为一个处理对象的，这种机制和sed是一样的。</p>
<p>cut -d’分隔字元’ -f fields</p>
<p>参数∶<br>-d ∶后面接分隔字元。与 -f 一起使用；<br>-f ∶依据 -d 的分隔字元将一段讯息分割成为数段，用 -f 取出第几段的意思；<br>-c ∶以字元 (characters) 的单位取出固定字元区间；</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">Linux的wc命令</div><br><div style="margin: 10px 0px; padding: 0px 0px 0px 10px; border: 1px solid #eff1f1; font-size: 14px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #f6745a; font-weight: bold; line-height: 25px; text-shadow: #f1f1f1 0px 1px 0px; background: #fbfbfb;">关于WC命令：</div>

<p>该命令统计给定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所有指定文件的总统计数。字是由空格字符区分开的最大字符串。</p>
<p><strong><br>该命令各选项含义如下：
</strong></p>
<p>wc -m filename：显示一个文件的字符数<br>wc -l filename：显示一个文件的行数<br>wc -L filename：显示一个文件中的最长行的长度<br>wc -w filename：显示一个文件的字数</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">关于ls命令</div>

<p>ls 命令经常要使用，通过使用 ls 命令可以查看linux文件夹包含的文件，查看文件权限(包括目录、文件夹、文件权限)，查看目录信息等等，ls 命令在平常的linux操作中使用很频繁，所以这里介绍下 ls 命令的相关使用方法。</p>
<p><strong><br>选项说明：
</strong></p>
<p>-a 用于显示所有文件和子目录(保罗点文件)。<br>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。<br>-r 将目录的内容清单以英文字母顺序的逆序显示。<br>-t 按文件修改时间进行排序，而不是按文件名进行排序。</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">关于sort命令</div>

<p>Sort命令的功能是对文件中的各行进行排序。Sort命令有许多非常实用的选项，这些选项最初是用来对数据库格式的文件内容进行各种排序操作的。实际上，Sort命令可以被认为是一个非常强大的数据管理工具，用来管理内容类似数据库记录的文件。<br>-n按照数字方式排序。不加-n参数时排序结果根据最左面的数字开始，等同于字母的比较方式。按算术值对数字字段排序。数字字段可包含前导空格、可选减号、十进制数字、千分位分隔符和可选基数符。对包含任何非数字字符的字段进行数字排序会出现无法预知的结果。</p>
<p>-r 颠倒指定排序的顺序。<br>-k作用是根据某个列来排序，默认是第1列（从1开始）。<br>-t表示分割符，以：分割，默认情况下以空格分割<br>-nrk 5即是按照数字方式倒序排序，根据文件属性的第5列即是文件大小排序</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">关于tr命令</div>

<p>通过使用 tr，可以非常容易地实现 sed 的许多最基本功能。可以将 tr 看作为 sed 的（极其）简化的变体。使用tr命令可以用一个字符来替换另一个字符，或者可以完全除去一些字符，也可以用它来除去重复字符。</p>
<p>tr的命令格式为：</p>
<p>tr -c -d -s [“string1_to_translate_from”] [“string2_to_translate_to”] &lt; input-file</p>
<p><strong><br>-c
</strong></p>
<p>用字符串1中字符集的补集替换此字符集，要求字符集为ASCII。</p>
<p><strong><br>-d
</strong></p>
<p>删除字符串1中所有输入字符。</p>
<p><strong><br>-s
</strong></p>
<p>删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。</p>
<p><strong><br>string1_to_translate_from
</strong></p>
<p>要转换的原字符串</p>
<p><strong><br>string2_to_translate_to
</strong></p>
<p>想要转换成的字符串</p>
<div style="margin: 10px 0px; padding: 0px 0px 0px 15px; border-width: 0px 0px 1px; border-bottom-style: outset; border-bottom-color: #e8e9e9; font-size: 15px; font-family: 'Courier New', 宋体, Consolas, 'YaHei Consolas Hybrid', 'Microsoft YaHei', Arial, Courier, monospace; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: #3f3f3f; font-weight: bold; line-height: 30px; text-shadow: #f1f1f1 0px 1px 0px; background: #dedede;">关于mv命令</div>

<p>mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。该命令等同于DOS系统下的ren和move命令的组合。它的使用权限是所有用户。</p>
<p>mv [options] 源文件或目录 目标文件或目录。k</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/sed-awk-grep-cut-find.html" data-id="cji8sg1ve00bu40io68wut5pv" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aix/">aix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hashmap-hashtable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hashmap-hashtable.html" class="article-date">
  <time datetime="2014-10-13T12:29:27.000Z" itemprop="datePublished">2014-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hashmap-hashtable.html">HashMap和Hashtable的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1 HashMap不是线程安全的</p>
<p>&nbsp;</p>
<p>hastmap是一个接口 是map接口的子接口，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap允许null key和null value，而hashtable不允许。</p>
<p>&nbsp;</p>
<p>2   HashTable是线程安全的一个Collection。</p>
<p>&nbsp;</p>
<p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。<br>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。<br>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。<br>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。<br>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。<br>Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p>
<p>&nbsp;</p>
<p>public static void main(String args[])<br>{<br>HashTable h=new HashTable();<br>h.put(“用户1”,new Integer(90));<br>h.put(“用户2”,new Integer(50));<br>h.put(“用户3”,new Integer(60));<br>h.put(“用户4”,new Integer(70));<br>h.put(“用户5”,new Integer(80));<br>Enumeration e=h.elements();<br>while(e.hasMoreElements()){<br>System.out.println(e.nextElement());<br>}</p>
<p>&nbsp;</p>
<p>map 的方法：</p>
<p>&nbsp;</p>
<p>clear()从 Map 中删除所有映射</p>
<p>&nbsp;</p>
<p>remove(Object key)从 Map 中删除键和关联的值<br>put(Object key, Object value)将指定值与指定键相关联</p>
<p>get(Object key)返回与指定键关联的值<br>containsKey(Object key)如果 Map 包含指定键的映射，则返回 true</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>containsValue(Object value)如果此 Map 将一个或多个键映射到指定值，则返回 true</p>
<p>&nbsp;</p>
<p>isEmpty()如果 Map 不包含键-值映射，则返回 true size()返回 Map 中的键-值映射的数目</p>
<p>这些都代表了Java中的集合，这里主要从其元素是否有序，是否可重复来进行区别记忆，以便恰当地使用，当然还存在同步方面的差异，见上一篇相关文章。</p>
<p><table></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td colspan="2" width="147"></td></p>
<p><td width="245"><br>有序否</td></p>
<p><td width="176"><br>允许元素重复否</td><br></p>
<p><tr></tr></p>
<p><td colspan="2" width="147"><br>Collection</td></p>
<p><td width="245"><br>否</td></p>
<p><td width="176"><br>是</td><br></p>
<p><tr></tr></p>
<p><td colspan="2" width="147"><br>List</td></p>
<p><td width="245"><br>是</td></p>
<p><td width="176"><br>是</td><br></p>
<p><tr></tr></p>
<p><td rowspan="3" width="56"><br>Set</td></p>
<p><td width="91"><br>AbstractSet</td></p>
<p><td rowspan="2" width="245"><br>否</td></p>
<p><td rowspan="3" width="176"><br>否</td><br></p>
<p><tr></tr></p>
<p><td width="91"><br>HashSet</td><br></p>
<p><tr></tr></p>
<p><td width="91"><br>TreeSet</td></p>
<p><td width="245"><br>是（用二叉树排序）</td><br></p>
<p><tr></tr></p>
<p><td rowspan="3" width="56"><br>Map</td></p>
<p><td width="91"><br>AbstractMap</td></p>
<p><td rowspan="2" width="245"><br>否</td></p>
<p><td rowspan="3" width="176"><br>使用key-value来映射和存储数据，Key必须惟一，value可以重复</td><br></p>
<p><tr></tr></p>
<p><td width="91"><br>HashMap</td><br></p>
<p><tr></tr></p>
<p><td width="91"><br>TreeMap</td></p>
<p><td width="245"><br>是（用二叉树排序）</td><br><br><br><br>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>List 接口对Collection进行了简单的扩充，它的具体实现类常用的有ArrayList和LinkedList。你可以将任何东西放到一个List容器中，并在需要时从中取出。ArrayList从其命名中可以看出它是一种类似数组的形式进行存储，因此它的随机访问速度极快，而LinkedList的内部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作。在具体应用时可以根据需要自由选择。前面说的Iterator只能对容器进行向前遍历，而 ListIterator则继承了Iterator的思想，并提供了对List进行双向遍历的方法。</p>
<p>Set接口也是 Collection的一种扩展，而与List不同的时，在Set中的对象元素不能重复，也就是说你不能把同样的东西两次放入同一个Set容器中。它的常用具体实现有HashSet和TreeSet类。HashSet能快速定位一个元素，但是你放到HashSet中的对象需要实现hashCode()方法，它使用了前面说过的哈希码的算法。而TreeSet则将放入其中的元素按序存放，这就要求你放入其中的对象是可排序的，这就用到了集合框架提供的另外两个实用类Comparable和Comparator。一个类是可排序的，它就应该实现Comparable接口。有时多个类具有相同的排序算法，那就不需要在每分别重复定义相同的排序算法，只要实现Comparator接口即可。集合框架中还有两个很实用的公用类：Collections和 Arrays。Collections提供了对一个Collection容器进行诸如排序、复制、查找和填充等一些非常有用的方法，Arrays则是对一个数组进行类似的操作。</p>
<p>Map是一种把键对象和值对象进行关联的容器，而一个值对象又可以是一个Map，依次类推，这样就可形成一个多级映射。对于键对象来说，像Set一样，一个Map容器中的键对象不允许重复，这是为了保持查找结果的一致性;如果有两个键对象一样，那你想得到那个键对象所对应的值对象时就有问题了，可能你得到的并不是你想的那个值对象，结果会造成混乱，所以键的唯一性很重要，也是符合集合的性质的。当然在使用过程中，某个键所对应的值对象可能会发生变化，这时会按照最后一次修改的值对象与键对应。对于值对象则没有唯一性的要求。你可以将任意多个键都映射到一个值对象上，这不会发生任何问题（不过对你的使用却可能会造成不便，你不知道你得到的到底是那一个键所对应的值对象）。Map有两种比较常用的实现： HashMap和TreeMap。HashMap也用到了哈希码的算法，以便快速查找一个键，TreeMap则是对键按序存放，因此它便有一些扩展的方法，比如firstKey(),lastKey()等，你还可以从TreeMap中指定一个范围以取得其子Map。键和值的关联很简单，用pub (Object key,Object value)方法即可将一个键与一个值对象相关联。用get(Object key)可得到与此key对象所对应的值对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/hashmap-hashtable.html" data-id="cji8sg1rw005640ioncnwlnuu" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-process-thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/process-thread.html" class="article-date">
  <time datetime="2014-10-13T12:28:11.000Z" itemprop="datePublished">2014-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Program/">Program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/process-thread.html">进程与线程的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>线程是指进程内的一个执行单元,也是进程内的可调度实体.<br>与进程的区别:<br>(1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;<br>(2)资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源<br>(3)线程是处理器调度的基本单位,但进程不是.<br>4)二者均可并发执行.</p>
<p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：</p>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.ibmer.info/process-thread.html" data-id="cji8sg1tz009f40ioewwa3fsl" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理论/">理论</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/10/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/12/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MiddleWare/">MiddleWare</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OperatingSystem/">OperatingSystem</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Program/">Program</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Salesforce/">Salesforce</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日本/">日本</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apex/">Apex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB2/">DB2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IBM/">IBM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IT/">IT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SFDC/">SFDC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOA/">SOA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Salesforce/">Salesforce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SalesforceExam/">SalesforceExam</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SalesforceTest/">SalesforceTest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SalesforceXyTools/">SalesforceXyTools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aix/">aix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cloud/">cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eclipse/">eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ecshop/">ecshop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ilmt/">ilmt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jython/">jython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vba/">vba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/">vmware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/was/">was</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websphere/">websphere</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wordpress/">wordpress</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信/">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库优化/">数据库优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日本/">日本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试，test/">测试，test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/理论/">理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Apex/" style="font-size: 14.17px;">Apex</a> <a href="/tags/DB2/" style="font-size: 10.83px;">DB2</a> <a href="/tags/Database/" style="font-size: 14.17px;">Database</a> <a href="/tags/IBM/" style="font-size: 11.67px;">IBM</a> <a href="/tags/IT/" style="font-size: 12.5px;">IT</a> <a href="/tags/SFDC/" style="font-size: 14.17px;">SFDC</a> <a href="/tags/SOA/" style="font-size: 10.83px;">SOA</a> <a href="/tags/Salesforce/" style="font-size: 20px;">Salesforce</a> <a href="/tags/SalesforceExam/" style="font-size: 10px;">SalesforceExam</a> <a href="/tags/SalesforceTest/" style="font-size: 10px;">SalesforceTest</a> <a href="/tags/SalesforceXyTools/" style="font-size: 15.83px;">SalesforceXyTools</a> <a href="/tags/aix/" style="font-size: 11.67px;">aix</a> <a href="/tags/android/" style="font-size: 14.17px;">android</a> <a href="/tags/apache/" style="font-size: 10px;">apache</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/cloud/" style="font-size: 10px;">cloud</a> <a href="/tags/eclipse/" style="font-size: 10.83px;">eclipse</a> <a href="/tags/ecshop/" style="font-size: 11.67px;">ecshop</a> <a href="/tags/ilmt/" style="font-size: 12.5px;">ilmt</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/jython/" style="font-size: 10px;">jython</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/mq/" style="font-size: 10px;">mq</a> <a href="/tags/mysql/" style="font-size: 14.17px;">mysql</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/php/" style="font-size: 18.33px;">php</a> <a href="/tags/python/" style="font-size: 10.83px;">python</a> <a href="/tags/shell/" style="font-size: 10.83px;">shell</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/vba/" style="font-size: 10.83px;">vba</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/was/" style="font-size: 15px;">was</a> <a href="/tags/websphere/" style="font-size: 10px;">websphere</a> <a href="/tags/windows/" style="font-size: 14.17px;">windows</a> <a href="/tags/wordpress/" style="font-size: 16.67px;">wordpress</a> <a href="/tags/分布式/" style="font-size: 13.33px;">分布式</a> <a href="/tags/微信/" style="font-size: 10.83px;">微信</a> <a href="/tags/数据库/" style="font-size: 10.83px;">数据库</a> <a href="/tags/数据库优化/" style="font-size: 10.83px;">数据库优化</a> <a href="/tags/日本/" style="font-size: 10.83px;">日本</a> <a href="/tags/测试，test/" style="font-size: 10px;">测试，test</a> <a href="/tags/理论/" style="font-size: 19.17px;">理论</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2001/01/">January 2001</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2000/01/">January 2000</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hello-world.html">Hello World</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-ApexCreator.html">SalesforceXyTools Sublime ApexCreator</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-ExportToExcel.html">SalesforceXyTools Sublime Export SObject To Excel</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-TestCodeCreator.html">SalesforceXyTools Sublime Test Code Creator</a>
          </li>
        
          <li>
            <a href="/SalesforceXyTools-Sublime-Install.html">SalesforceXyTools Sublime Install Help</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
      邮箱：exia.sfdc@outlook.com<br />
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Exia.Huang<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>